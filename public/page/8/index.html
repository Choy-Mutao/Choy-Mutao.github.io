<!DOCTYPE html>
<html lang="en-us">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

  	<meta property="og:title" content=" 穆 道" />
  	<meta property="og:site_name" content="穆 道" />
  	<meta property="og:url" content="https://choy-mutao.github.io/" />
    
    
    <meta property="og:type" content="website" />
    

  <title>
     穆 道
  </title>

    <meta name="description" content="Note Book" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="https://choy-mutao.github.io/images/favicon.ico">
	  <link rel="apple-touch-icon" href="https://choy-mutao.github.io/images/apple-touch-icon.png" />
    
    <link rel="stylesheet" type="text/css" href="https://choy-mutao.github.io/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400|Inconsolata" />


    
      
      
        <link href="/index.xml" rel="alternate" type="application/rss+xml" title="穆 道" />
      
    
    <meta name="generator" content="Hugo 0.68.3" />

    <link rel="canonical" href="https://choy-mutao.github.io/" />

     
</head>
<body class="nav-closed">
<div id="particles-js"></div>
  


 <div class="site-wrapper">



<header class="main-header " style="background-image: url(https://choy-mutao.github.io/images/user.jpg)">


    

    <nav class="main-nav overlay clearfix">
        
            <a class="blog-logo" href="https://choy-mutao.github.io/"><img src="https://choy-mutao.github.io/images/user.png" alt="Blog Logo" s/></a>
        
        
    </nav>
<div class="vertical">
        <div class="main-header-content inner">
            <h1 class="page-title">
              <a class="btn-bootstrap-2 title-scroll" href="#content">穆 道</a>
          </h1>
          <h2 class="page-description">Note Book</h2>
        </div>
</div>
    <a class="scroll-down icon-arrow-left" href="#content"><span class="hidden">Scroll Down</span></a>
</header>

<main id="content" class="content" role="main">
    
    
    
    
    
    

    <div class="extra-pagination inner">
        <nav class="pagination" role="navigation">
	
	    <a class="newer-posts" href="/page/7/">&larr; Newer Posts</a>
	
	<span class="page-number">Page 8 of 17</span>
	
	    <a class="older-posts" href="/page/9/">Older Posts &rarr;</a>
	
</nav>

    </div>

    
        
<article class="post Basic">
    <header class="post-header">
        <h2 class="post-title"><a href="/basic/typescript/decorator/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h1 id="decorators">Decorators</h1>
<h2 id="装饰器-反射机制">装饰器 反射机制</h2>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://choy-mutao.github.io/images/user.png" alt="Author image" nopin="nopin" />
        
        
            Choy
        
        
        <time class="post-date" datetime="0001-01-01T00:00:00Z">
            1 Jan 0001
        </time>
    </footer>
</article>

    
        
<article class="post Basic">
    <header class="post-header">
        <h2 class="post-title"><a href="/basic/typescript/overview/typescript-3.9/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h2 id="inference-和-promiseall-的改进">Inference 和 Promise.all 的改进</h2>
<p>最近发布的 3.7 版本主要更新了对 <code>Promise.all</code> 和 <code>Promise.race</code> 的描述。 但不巧的是，这部分引入了一些版本回退， 尤其在联合类型中使用 <code>null</code> 和 <code>undefined</code> 时。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Lion</span> {
  <span style="color:#a6e22e">roar</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
}

<span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Seal</span> {
  <span style="color:#a6e22e">singKissFromARose</span>()<span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>;
}

<span style="color:#a6e22e">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">visitZoo</span>(
  <span style="color:#a6e22e">lionExhibit</span>: <span style="color:#66d9ef">Promise</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">Lion</span><span style="color:#f92672">&gt;</span>,
  <span style="color:#a6e22e">sealExhibit</span>: <span style="color:#66d9ef">Promise</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">Seal</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">undefined</span><span style="color:#f92672">&gt;</span>
) {
  <span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">lion</span>, <span style="color:#a6e22e">seal</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">await</span> <span style="color:#a6e22e">Promise</span>.<span style="color:#a6e22e">all</span>([<span style="color:#a6e22e">lionExhibit</span>, <span style="color:#a6e22e">sealExhibit</span>]);
  <span style="color:#a6e22e">lion</span>.<span style="color:#a6e22e">roar</span>(); <span style="color:#75715e">// uh oh
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//  ~~~~
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Object is possibly &#39;undefined&#39;.
</span><span style="color:#75715e"></span>}
</code></pre></div><p>这里得到了一个很奇怪的结果。</p>
<h2 id="新加了两个注解-ts-expect-error--ts-ignore">新加了两个注解 <code>//@ts-expect-error</code> &amp; <code>//@ts-ignore</code></h2>
<p>Pick ts-expect-error if:</p>
<p>you’re writing test code where you actually want the type system to error on an operation
you expect a fix to be coming in fairly quickly and you just need a quick workaround
you’re in a reasonably-sized project with a proactive team that wants to remove suppression comments as soon affected code is valid again
Pick ts-ignore if:</p>
<p>you have an a larger project and and new errors have appeared in code with no clear owner
you are in the middle of an upgrade between two different versions of TypeScript, and a line of code errors in one version but not another.
you honestly don’t have the time to decide which of these options is better.</p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://choy-mutao.github.io/images/user.png" alt="Author image" nopin="nopin" />
        
        
            Choy
        
        
        <time class="post-date" datetime="0001-01-01T00:00:00Z">
            1 Jan 0001
        </time>
    </footer>
</article>

    
        
<article class="post Basic">
    <header class="post-header">
        <h2 class="post-title"><a href="/basic/typescript/overview/typescript-4.0/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h1 id="typescript-40">TypeScript 4.0</h1>
<h2 id="variadic-tuple-types">Variadic Tuple Types</h2>
<p>Consider a function in JavaScript called concat that takes two array or tuple types and concatenates them together to make a new array.
创建一个 <code>concat</code> 的javascript函数，这个函数实现了将两个数组入参合并后返回。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">concat</span>(<span style="color:#a6e22e">arr1</span>, <span style="color:#a6e22e">arr2</span>) {
  <span style="color:#66d9ef">return</span> [...<span style="color:#a6e22e">arr1</span>, ...<span style="color:#a6e22e">arr2</span>];
}
</code></pre></div><p>Also consider tail, that takes an array or tuple, and returns all elements but the first.
再写一个函数 <code>tail</code>，将一个 array 或者 tuple 返回除了第一个元素的其他所有元素。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">tail</span>(<span style="color:#a6e22e">arg</span>) {
  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">_</span>, ...<span style="color:#a6e22e">result</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">arg</span>;
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>;
}
</code></pre></div><p>How would we type either of these in TypeScript?
我们在 typescript 中如何写这两个函数</p>
<p>For concat, the only valid thing we could do in older versions of the language was to try and write some overloads.
对于 <code>concat</code>， 旧版本中，我们唯一能做的只有尝试写一些重载函数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">concat</span>(<span style="color:#a6e22e">arr1</span><span style="color:#f92672">:</span> [], <span style="color:#a6e22e">arr2</span><span style="color:#f92672">:</span> [])<span style="color:#f92672">:</span> [];
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">concat</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">A</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">arr1</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">A</span>], <span style="color:#a6e22e">arr2</span><span style="color:#f92672">:</span> [])<span style="color:#f92672">:</span> [<span style="color:#a6e22e">A</span>];
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">concat</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">B</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">arr1</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">B</span>], <span style="color:#a6e22e">arr2</span><span style="color:#f92672">:</span> [])<span style="color:#f92672">:</span> [<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">B</span>];
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">concat</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">B</span>, <span style="color:#a6e22e">C</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">arr1</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">B</span>, <span style="color:#a6e22e">C</span>], <span style="color:#a6e22e">arr2</span><span style="color:#f92672">:</span> [])<span style="color:#f92672">:</span> [<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">B</span>, <span style="color:#a6e22e">C</span>];
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">concat</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">B</span>, <span style="color:#a6e22e">C</span>, <span style="color:#a6e22e">D</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">arr1</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">B</span>, <span style="color:#a6e22e">C</span>, <span style="color:#a6e22e">D</span>], <span style="color:#a6e22e">arr2</span><span style="color:#f92672">:</span> [])<span style="color:#f92672">:</span> [<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">B</span>, <span style="color:#a6e22e">C</span>, <span style="color:#a6e22e">D</span>];
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">concat</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">B</span>, <span style="color:#a6e22e">C</span>, <span style="color:#a6e22e">D</span>, <span style="color:#a6e22e">E</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">arr1</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">B</span>, <span style="color:#a6e22e">C</span>, <span style="color:#a6e22e">D</span>, <span style="color:#a6e22e">E</span>], <span style="color:#a6e22e">arr2</span><span style="color:#f92672">:</span> [])<span style="color:#f92672">:</span> [<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">B</span>, <span style="color:#a6e22e">C</span>, <span style="color:#a6e22e">D</span>, <span style="color:#a6e22e">E</span>];
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">concat</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">B</span>, <span style="color:#a6e22e">C</span>, <span style="color:#a6e22e">D</span>, <span style="color:#a6e22e">E</span>, <span style="color:#a6e22e">F</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">arr1</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">B</span>, <span style="color:#a6e22e">C</span>, <span style="color:#a6e22e">D</span>, <span style="color:#a6e22e">E</span>, <span style="color:#a6e22e">F</span>], <span style="color:#a6e22e">arr2</span><span style="color:#f92672">:</span> [])<span style="color:#f92672">:</span> [<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">B</span>, <span style="color:#a6e22e">C</span>, <span style="color:#a6e22e">D</span>, <span style="color:#a6e22e">E</span>, <span style="color:#a6e22e">F</span>];)
</code></pre></div><p>Uh…okay, that’s…seven overloads for when the second array is always empty. Let’s add some for when arr2 has one argument.
恩，上面只是给 arr1 增加到7个重载的，而 arr2 还是空的。那我们再给 arr2 加点参数呢</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">concat</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">A2</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">arr1</span><span style="color:#f92672">:</span> [], <span style="color:#a6e22e">arr2</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">A2</span>])<span style="color:#f92672">:</span> [<span style="color:#a6e22e">A2</span>];
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">concat</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">A1</span>, <span style="color:#a6e22e">A2</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">arr1</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">A1</span>], <span style="color:#a6e22e">arr2</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">A2</span>])<span style="color:#f92672">:</span> [<span style="color:#a6e22e">A1</span>, <span style="color:#a6e22e">A2</span>];
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">concat</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">A1</span>, <span style="color:#a6e22e">B1</span>, <span style="color:#a6e22e">A2</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">arr1</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">A1</span>, <span style="color:#a6e22e">B1</span>], <span style="color:#a6e22e">arr2</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">A2</span>])<span style="color:#f92672">:</span> [<span style="color:#a6e22e">A1</span>, <span style="color:#a6e22e">B1</span>, <span style="color:#a6e22e">A2</span>];
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">concat</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">A1</span>, <span style="color:#a6e22e">B1</span>, <span style="color:#a6e22e">C1</span>, <span style="color:#a6e22e">A2</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">arr1</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">A1</span>, <span style="color:#a6e22e">B1</span>, <span style="color:#a6e22e">C1</span>], <span style="color:#a6e22e">arr2</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">A2</span>])<span style="color:#f92672">:</span> [<span style="color:#a6e22e">A1</span>, <span style="color:#a6e22e">B1</span>, <span style="color:#a6e22e">C1</span>, <span style="color:#a6e22e">A2</span>];
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">concat</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">A1</span>, <span style="color:#a6e22e">B1</span>, <span style="color:#a6e22e">C1</span>, <span style="color:#a6e22e">D1</span>, <span style="color:#a6e22e">A2</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">arr1</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">A1</span>, <span style="color:#a6e22e">B1</span>, <span style="color:#a6e22e">C1</span>, <span style="color:#a6e22e">D1</span>], <span style="color:#a6e22e">arr2</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">A2</span>])<span style="color:#f92672">:</span> [<span style="color:#a6e22e">A1</span>, <span style="color:#a6e22e">B1</span>, <span style="color:#a6e22e">C1</span>, <span style="color:#a6e22e">D1</span>, <span style="color:#a6e22e">A2</span>];
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">concat</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">A1</span>, <span style="color:#a6e22e">B1</span>, <span style="color:#a6e22e">C1</span>, <span style="color:#a6e22e">D1</span>, <span style="color:#a6e22e">E1</span>, <span style="color:#a6e22e">A2</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">arr1</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">A1</span>, <span style="color:#a6e22e">B1</span>, <span style="color:#a6e22e">C1</span>, <span style="color:#a6e22e">D1</span>, <span style="color:#a6e22e">E1</span>], <span style="color:#a6e22e">arr2</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">A2</span>])<span style="color:#f92672">:</span> [<span style="color:#a6e22e">A1</span>, <span style="color:#a6e22e">B1</span>, <span style="color:#a6e22e">C1</span>, <span style="color:#a6e22e">D1</span>, <span style="color:#a6e22e">E1</span>, <span style="color:#a6e22e">A2</span>];
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">concat</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">A1</span>, <span style="color:#a6e22e">B1</span>, <span style="color:#a6e22e">C1</span>, <span style="color:#a6e22e">D1</span>, <span style="color:#a6e22e">E1</span>, <span style="color:#a6e22e">F1</span>, <span style="color:#a6e22e">A2</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">arr1</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">A1</span>, <span style="color:#a6e22e">B1</span>, <span style="color:#a6e22e">C1</span>, <span style="color:#a6e22e">D1</span>, <span style="color:#a6e22e">E1</span>, <span style="color:#a6e22e">F1</span>], <span style="color:#a6e22e">arr2</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">A2</span>])<span style="color:#f92672">:</span> [<span style="color:#a6e22e">A1</span>, <span style="color:#a6e22e">B1</span>, <span style="color:#a6e22e">C1</span>, <span style="color:#a6e22e">D1</span>, <span style="color:#a6e22e">E1</span>, <span style="color:#a6e22e">F1</span>, <span style="color:#a6e22e">A2</span>];
</code></pre></div><p>We hope it’s clear that this is getting unreasonable. Unfortunately, you’d also end up with the same sorts of issues typing a function like tail.
我们希望代码可以更清楚点，但是显而易见，已经很混乱了。不幸的事，同样的方法去实现 function<code>tail</code>， 也会出现同样的不可理喻的结果。</p>
<p>This is another case of what we like to call “death by a thousand overloads”, and it doesn’t even solve the problem generally. It only gives correct types for as many overloads as we care to write. If we wanted to make a catch-all case, we’d need an overload like the following:
还有一种被我们称为 <code>死亡重载</code> 的情况，通常来讲，无解！为了能正确运行我们只有尽量重载足够多的情况。如果我们要穷举所有的情况，我们只能写一个如下的重载函数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">concat</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span>, <span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">arr1</span>: <span style="color:#66d9ef">T</span>[], <span style="color:#a6e22e">arr2</span>: <span style="color:#66d9ef">U</span>[])<span style="color:#f92672">:</span> Array<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span>;
</code></pre></div><p>But that signature doesn’t encode anything about the lengths of the input, or the order of the elements, when using tuples.
但是当我们使用 <code>tuples</code> 的时候，<code>signature</code> 不会对输入的长度和元素的顺序进行编码， <code>signature</code>是什么</p>
<p>TypeScript 4.0 brings two fundamental changes, along with inference improvements, to make typing these possible.
Typescript 4.0 版本带来了<code>两个</code>基础的改变，通过对 <code>inference</code> 的优化，使得上述情况称为可能，就是为了让上述情况写得更简单，清楚。</p>
<p>The first change is that spreads in tuple type syntax can now be generic. This means that we can represent higher-order operations on tuples and arrays even when we don’t know the actual types we’re operating over. When generic spreads are instantiated (or, replaced with a real type) in these tuple types, they can produce other sets of array and tuple types.</p>
<ol>
<li>tuple 语法的传参可以通用。这意味着即使我们不知道要操作的实际类型，我们也可以表示对元组和数组的高阶操作。当在这些元组类型中实例化通用扩展（或用实型替换）时，它们可以产生其他数组和元组类型集。</li>
</ol>
<p>For example, that means we can type function like tail, without our “death by a thousand overloads” issue.
例如，这意味着我们可以像<code>tail</code>那样键入函数，而不会出现<code>死亡重载</code>的问题。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">tail</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">any</span>[]<span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">arr</span>: <span style="color:#66d9ef">readonly</span> [<span style="color:#a6e22e">any</span>, ...<span style="color:#a6e22e">T</span>]) {
  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">_ignored</span>, ...<span style="color:#a6e22e">rest</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">arr</span>;
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">rest</span>;
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">myTuple</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>;
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">myArray</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;hello&#34;</span>, <span style="color:#e6db74">&#34;world&#34;</span>];

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">r1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">tail</span>(<span style="color:#a6e22e">myTuple</span>);
<span style="color:#75715e">//    ^ = const r1: [2, 3, 4]
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">r2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">tail</span>([...<span style="color:#a6e22e">myTuple</span>, ...<span style="color:#a6e22e">myArray</span>] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">const</span>);
<span style="color:#75715e">//    ^ = const r2: [2, 3, 4, ...string[]]Try
</span></code></pre></div><p>The second change is that rest elements can occur anywhere in a tuple - not just at the end!
2. 第二个变化是，其余元素可以在元组中的任何位置出现-不只是在结尾！</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#a6e22e">type</span> <span style="color:#a6e22e">Strings</span> <span style="color:#f92672">=</span> [<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">string</span>];
<span style="color:#a6e22e">type</span> <span style="color:#a6e22e">Numbers</span> <span style="color:#f92672">=</span> [<span style="color:#66d9ef">number</span>, <span style="color:#66d9ef">number</span>];

<span style="color:#a6e22e">type</span> <span style="color:#a6e22e">StrStrNumNumBool</span> <span style="color:#f92672">=</span> [...<span style="color:#a6e22e">Strings</span>, ...<span style="color:#a6e22e">Numbers</span>, <span style="color:#66d9ef">boolean</span>];
<span style="color:#75715e">//   ^ = type StrStrNumNumBool = [string, string, number, number, boolean]Try
</span></code></pre></div><p>Previously, TypeScript would issue an error like the following:
以前，TypeScript会发出如下错误：</p>
<blockquote>
<p>A rest element must be last in a tuple type.</p>
</blockquote>
<p>But with TypeScript 4.0, this restriction is relaxed.
但是使用TypeScript 4.0可以放宽此限制。</p>
<p>Note that in cases when we spread in a type without a known length, the resulting type becomes unbounded as well, and all the following elements factor into the resulting rest element type.
但是要注意的是，当我们要展开一个未知长度类型时，结果类型变得不被限制了，并且所有以下所有元素都会计入所得的其余元素类型。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#a6e22e">type</span> <span style="color:#a6e22e">Strings</span> <span style="color:#f92672">=</span> [<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">string</span>];
<span style="color:#a6e22e">type</span> <span style="color:#a6e22e">Numbers</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">number</span>[];

<span style="color:#a6e22e">type</span> <span style="color:#a6e22e">Unbounded</span> <span style="color:#f92672">=</span> [...<span style="color:#a6e22e">Strings</span>, ...<span style="color:#a6e22e">Numbers</span>, <span style="color:#66d9ef">boolean</span>];
<span style="color:#75715e">//   ^ = type Unbounded = [string, string, ...(number | boolean)[]]Try
</span></code></pre></div><p>By combining both of these behaviors together, we can write a single well-typed signature for concat:
通过将这两种行为结合在一起，我们可以为concat编写一个类型良好的签名：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#a6e22e">type</span> <span style="color:#a6e22e">Arr</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">readonly</span> <span style="color:#a6e22e">any</span>[];

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">concat</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Arr</span>, <span style="color:#a6e22e">U</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Arr</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">arr1</span>: <span style="color:#66d9ef">T</span>, <span style="color:#a6e22e">arr2</span>: <span style="color:#66d9ef">U</span>)<span style="color:#f92672">:</span> [...<span style="color:#a6e22e">T</span>, ...<span style="color:#a6e22e">U</span>] {
  <span style="color:#66d9ef">return</span> [...<span style="color:#a6e22e">arr1</span>, ...<span style="color:#a6e22e">arr2</span>];
}
</code></pre></div><p>While that one signature is still a bit lengthy, it’s just one signature that doesn’t have to be repeated, and it gives predictable behavior on all arrays and tuples.
尽管一个签名仍然有些冗长，但这只是一个签名，无需重复，它可以在所有数组和元组上提供可预测的行为。</p>
<p>This functionality on its own is great, but it shines in more sophisticated scenarios too. For example, consider a function to partially apply arguments called partialCall. partialCall takes a function - let’s call it f - along with the initial few arguments that f expects. It then returns a new function that takes any other arguments that f still needs, and calls f when it receives them.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">partialCall</span>(<span style="color:#a6e22e">f</span>, ...<span style="color:#a6e22e">headArgs</span>) {
  <span style="color:#66d9ef">return</span> (...<span style="color:#a6e22e">tailArgs</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">f</span>(...<span style="color:#a6e22e">headArgs</span>, ...<span style="color:#a6e22e">tailArgs</span>);
}
</code></pre></div><p>TypeScript 4.0 improves the inference process for rest parameters and rest tuple elements so that we can type this and have it “just work”.
TypeScript 4.0改进了rest参数和rest tuple元素的推断过程，因此我们可以键入它并使其“正常工作”。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#a6e22e">type</span> <span style="color:#a6e22e">Arr</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">readonly</span> <span style="color:#a6e22e">unknown</span>[];

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">partialCall</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">T</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Arr</span>, <span style="color:#a6e22e">U</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Arr</span>, <span style="color:#a6e22e">R</span><span style="color:#f92672">&gt;</span>(
  <span style="color:#a6e22e">f</span><span style="color:#f92672">:</span> (...<span style="color:#a6e22e">args</span><span style="color:#f92672">:</span> [...<span style="color:#a6e22e">T</span>, ...<span style="color:#a6e22e">U</span>]) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">R</span>,
  ...<span style="color:#a6e22e">headArgs</span>: <span style="color:#66d9ef">T</span>
) {
  <span style="color:#66d9ef">return</span> (...<span style="color:#a6e22e">tailArgs</span>: <span style="color:#66d9ef">U</span>) <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">f</span>(...<span style="color:#a6e22e">headArgs</span>, ...<span style="color:#a6e22e">tailArgs</span>);
}
</code></pre></div><p>In this case, partialCall understands which parameters it can and can’t initially take, and returns functions that appropriately accept and reject anything left over.
在这种情况下，partialCall会了解其最初可以使用和不能使用的参数，并返回可以正确接受和拒绝剩余内容的函数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">foo</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">x</span>: <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">y</span>: <span style="color:#66d9ef">number</span>, <span style="color:#a6e22e">z</span>: <span style="color:#66d9ef">boolean</span>) <span style="color:#f92672">=&gt;</span> {};

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">f1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">partialCall</span>(<span style="color:#a6e22e">foo</span>, <span style="color:#ae81ff">100</span>);
</code></pre></div><p>Argument of type &lsquo;number&rsquo; is not assignable to parameter of type &lsquo;string&rsquo;.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">f2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">partialCall</span>(<span style="color:#a6e22e">foo</span>, <span style="color:#e6db74">&#34;hello&#34;</span>, <span style="color:#ae81ff">100</span>, <span style="color:#66d9ef">true</span>, <span style="color:#e6db74">&#34;oops&#34;</span>);
</code></pre></div><p>Expected 4 arguments, but got 5.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-typescript" data-lang="typescript"><span style="color:#75715e">// This works!
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">f3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">partialCall</span>(<span style="color:#a6e22e">foo</span>, <span style="color:#e6db74">&#34;hello&#34;</span>);
<span style="color:#75715e">//    ^ = const f3: (y: number, z: boolean) =&gt; void
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// What can we do with f3 now?
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// Works!
</span><span style="color:#75715e"></span><span style="color:#a6e22e">f3</span>(<span style="color:#ae81ff">123</span>, <span style="color:#66d9ef">true</span>);

<span style="color:#a6e22e">f3</span>();
</code></pre></div><p>Expected 2 arguments, but got 0.</p>
<p>f3(123, &ldquo;hello&rdquo;);
Argument of type &lsquo;string&rsquo; is not assignable to parameter of type &lsquo;boolean&rsquo;.</p>
<p>Variadic tuple types enable a lot of new exciting patterns, especially around function composition. We expect we may be able to leverage it to do a better job type-checking JavaScript’s built-in bind method. A handful of other inference improvements and patterns also went into this, and if you’re interested in learning more, you can take a look at the pull request for variadic tuples.</p>
<p>Labeled Tuple Elements
Improving the experience around tuple types and parameter lists is important because it allows us to get strongly typed validation around common JavaScript idioms - really just slicing and dicing argument lists and passing them to other functions. The idea that we can use tuple types for rest parameters is one place where this is crucial.</p>
<p>For example, the following function that uses a tuple type as a rest parameter…</p>
<p>function foo(&hellip;args: [string, number]): void {
// &hellip;
}
…should appear no different from the following function…</p>
<p>function foo(arg0: string, arg1: number): void {
// &hellip;
}
…for any caller of foo.</p>
<p>foo(&ldquo;hello&rdquo;, 42);</p>
<p>foo(&ldquo;hello&rdquo;, 42, true);
Expected 2 arguments, but got 3.
foo(&ldquo;hello&rdquo;);
Expected 2 arguments, but got 1.</p>
<p>There is one place where the differences begin to become observable though: readability. In the first example, we have no parameter names for the first and second elements. While these have no impact on type-checking, the lack of labels on tuple positions can make them harder to use - harder to communicate our intent.</p>
<p>That’s why in TypeScript 4.0, tuples types can now provide labels.</p>
<p>type Range = [start: number, end: number];
To deepen the connection between parameter lists and tuple types, the syntax for rest elements and optional elements mirrors the syntax for parameter lists.</p>
<p>type Foo = [first: number, second?: string, &hellip;rest: any[]];
There are a few rules when using labeled tuples. For one, when labeling a tuple element, all other elements in the tuple must also be labeled.</p>
<p>type Bar = [first: string, number];
Tuple members must all have names or all not have names.</p>
<p>It’s worth noting - labels don’t require us to name our variables differently when destructuring. They’re purely there for documentation and tooling.</p>
<p>function foo(x: [first: string, second: number]) {
// &hellip;</p>
<pre><code>// note: we didn't need to name these 'first' and 'second'
const [a, b] = x;
a
</code></pre>
<p>//  ^ = const a: string
b
//  ^ = const b: number
}
Overall, labeled tuples are handy when taking advantage of patterns around tuples and argument lists, along with implementing overloads in a type-safe way. In fact, TypeScript’s editor support will try to display them as overloads when possible.</p>
<p>Signature help displaying a union of labeled tuples as in a parameter list as two signatures</p>
<p>To learn more, check out the pull request for labeled tuple elements.</p>
<p>Class Property Inference from Constructors
TypeScript 4.0 can now use control flow analysis to determine the types of properties in classes when noImplicitAny is enabled.</p>
<p>class Square {
// Previously both of these were any
area;
// ^ = (property) Square.area: number
sideLength;
// ^ = (property) Square.sideLength: number
constructor(sideLength: number) {
this.sideLength = sideLength;
this.area = sideLength ** 2;
}
}
In cases where not all paths of a constructor assign to an instance member, the property is considered to potentially be undefined.</p>
<p>class Square {
sideLength;
// ^ = (property) Square.sideLength: number | undefined</p>
<p>constructor(sideLength: number) {
if (Math.random()) {
this.sideLength = sideLength;
}
}</p>
<p>get area() {
return this.sideLength ** 2;
Object is possibly &lsquo;undefined&rsquo;.
}
}
In cases where you know better (e.g. you have an initialize method of some sort), you’ll still need an explicit type annotation along with a definite assignment assertion (!) if you’re in strictPropertyInitialization.</p>
<p>class Square {
// definite assignment assertion
//        v
sideLength!: number;
//         ^^^^^^^^
// type annotation</p>
<p>constructor(sideLength: number) {
this.initialize(sideLength);
}</p>
<p>initialize(sideLength: number) {
this.sideLength = sideLength;
}</p>
<p>get area() {
return this.sideLength ** 2;
}
}
For more details, see the implementing pull request.</p>
<p>Short-Circuiting Assignment Operators
JavaScript, and a lot of other languages, support a set of operators called compound assignment operators. Compound assignment operators apply an operator to two arguments, and then assign the result to the left side. You may have seen these before:</p>
<p>// Addition
// a = a + b
a += b;</p>
<p>// Subtraction
// a = a - b
a -= b;</p>
<p>// Multiplication
// a = a * b
a *= b;</p>
<p>// Division
// a = a / b
a /= b;</p>
<p>// Exponentiation
// a = a ** b
a **= b;</p>
<p>// Left Bit Shift
// a = a &laquo; b
a &laquo;= b;
So many operators in JavaScript have a corresponding assignment operator! Up until recently, however, there were three notable exceptions: logical and (&amp;&amp;), logical or (||), and nullish coalescing (??).</p>
<p>That’s why TypeScript 4.0 supports a new ECMAScript feature to add three new assignment operators: &amp;&amp;=, ||=, and ??=.</p>
<p>These operators are great for substituting any example where a user might write code like the following:</p>
<p>a = a &amp;&amp; b;
a = a || b;
a = a ?? b;
Or a similar if block like</p>
<p>// could be &lsquo;a ||= b&rsquo;
if (!a) {
a = b;
}
There are even some patterns we’ve seen (or, uh, written ourselves) to lazily initialize values, only if they’ll be needed.</p>
<p>let values: string[];
(values ?? (values = [])).push(&ldquo;hello&rdquo;);</p>
<p>// After
(values ??= []).push(&ldquo;hello&rdquo;);
(look, we’re not proud of all the code we write…)</p>
<p>On the rare case that you use getters or setters with side-effects, it’s worth noting that these operators only perform assignments if necessary. In that sense, not only is the right side of the operator “short-circuited” - the assignment itself is too.</p>
<p>obj.prop ||= foo();</p>
<p>// roughly equivalent to either of the following</p>
<p>obj.prop || (obj.prop = foo());</p>
<p>if (!obj.prop) {
obj.prop = foo();
}
Try running the following example to see how that differs from always performing the assignment.</p>
<p>const obj = {
get prop() {
console.log(&ldquo;getter has run&rdquo;);</p>
<pre><code>    // Replace me!
    return Math.random() &lt; 0.5;
},
set prop(_val: boolean) {
    console.log(&quot;setter has run&quot;);
}
</code></pre>
<p>};</p>
<p>function foo() {
console.log(&ldquo;right side evaluated&rdquo;);
return true;
}</p>
<p>console.log(&ldquo;This one always runs the setter&rdquo;);
obj.prop = obj.prop || foo();</p>
<p>console.log(&ldquo;This one <em>sometimes</em> runs the setter&rdquo;);
obj.prop ||= foo();Try
We’d like to extend a big thanks to community member Wenlu Wang for this contribution!</p>
<p>For more details, you can take a look at the pull request here. You can also check out TC39’s proposal repository for this feature.</p>
<p>unknown on catch Clause Bindings
Since the beginning days of TypeScript, catch clause variables have always been typed as any. This meant that TypeScript allowed you to do anything you wanted with them.</p>
<p>try {
// Do some work
} catch (x) {
// x has type &lsquo;any&rsquo; - have fun!
console.log(x.message);
console.log(x.toUpperCase());
x++;
x.yadda.yadda.yadda();
}
The above has some undesirable behavior if we’re trying to prevent more errors from happening in our error-handling code! Because these variables have the type any by default, they lack any type-safety which could have errored on invalid operations.</p>
<p>That’s why TypeScript 4.0 now lets you specify the type of catch clause variables as unknown instead. unknown is safer than any because it reminds us that we need to perform some sorts of type-checks before operating on our values.</p>
<p>try {
// &hellip;
} catch (e: unknown) {
// Can&rsquo;t access values on unknowns
console.log(e.toUpperCase());
Object is of type &lsquo;unknown&rsquo;.</p>
<p>if (typeof e === &ldquo;string&rdquo;) {
// We&rsquo;ve narrowed &lsquo;e&rsquo; down to the type &lsquo;string&rsquo;.
console.log(e.toUpperCase());
}
}
While the types of catch variables won’t change by default, we might consider a new &ndash;strict mode flag in the future so that users can opt in to this behavior. In the meantime, it should be possible to write a lint rule to force catch variables to have an explicit annotation of either : any or : unknown.</p>
<p>For more details you can peek at the changes for this feature.</p>
<p>Custom JSX Factories
When using JSX, a fragment is a type of JSX element that allows us to return multiple child elements. When we first implemented fragments in TypeScript, we didn’t have a great idea about how other libraries would utilize them. Nowadays most other libraries that encourage using JSX and support fragments have a similar API shape.</p>
<p>In TypeScript 4.0, users can customize the fragment factory through the new jsxFragmentFactory option.</p>
<p>As an example, the following tsconfig.json file tells TypeScript to transform JSX in a way compatible with React, but switches each factory invocation to h instead of React.createElement, and uses Fragment instead of React.Fragment.</p>
<p>{
compilerOptions: {
target: &ldquo;esnext&rdquo;,
module: &ldquo;commonjs&rdquo;,
jsx: &ldquo;react&rdquo;,
jsxFactory: &ldquo;h&rdquo;,
jsxFragmentFactory: &ldquo;Fragment&rdquo;,
},
}
In cases where you need to have a different JSX factory on a per-file basis, you can take advantage of the new /** @jsxFrag */ pragma comment. For example, the following…</p>
<p>// Note: these pragma comments need to be written
// with a JSDoc-style multiline syntax to take effect.</p>
<p>/** @jsx h */
/** @jsxFrag Fragment */</p>
<p>import { h, Fragment } from &ldquo;preact&rdquo;;</p>
<p>export const Header = (
&lt;&gt;
<!-- raw HTML omitted -->Welcome<!-- raw HTML omitted -->
&lt;/&gt;
);Try
…will get transformed to this output JavaScript…</p>
<p>// Note: these pragma comments need to be written
// with a JSDoc-style multiline syntax to take effect.
/** @jsx h */
/** @jsxFrag Fragment */
import { h, Fragment } from &ldquo;preact&rdquo;;
export const Header = (h(Fragment, null,
h(&ldquo;h1&rdquo;, null, &ldquo;Welcome&rdquo;)));Try
We’d like to extend a big thanks to community member Noj Vek for sending this pull request and patiently working with our team on it.</p>
<p>You can see that the pull request for more details!</p>
<p>Speed Improvements in build mode with &ndash;noEmitOnError
Previously, compiling a program after a previous compile with errors under &ndash;incremental would be extremely slow when using the &ndash;noEmitOnError flag. This is because none of the information from the last compilation would be cached in a .tsbuildinfo file based on the &ndash;noEmitOnError flag.</p>
<p>TypeScript 4.0 changes this which gives a great speed boost in these scenarios, and in turn improves &ndash;build mode scenarios (which imply both &ndash;incremental and &ndash;noEmitOnError).</p>
<p>For details, read up more on the pull request.</p>
<p>&ndash;incremental with &ndash;noEmit
TypeScript 4.0 allows us to use the &ndash;noEmit flag when while still leveraging &ndash;incremental compiles. This was previously not allowed, as &ndash;incremental needs to emit a .tsbuildinfo files; however, the use-case to enable faster incremental builds is important enough to enable for all users.</p>
<p>For more details, you can see the implementing pull request.</p>
<p>Editor Improvements
The TypeScript compiler doesn’t only power the editing experience for TypeScript itself in most major editors - it also powers the JavaScript experience in the Visual Studio family of editors and more. For that reason, much of our work focuses on improving editor scenarios - the place you spend most of your time as a developer.</p>
<p>Using new TypeScript/JavaScript functionality in your editor will differ depending on your editor, but</p>
<p>Visual Studio Code supports selecting different versions of TypeScript. Alternatively, there’s the JavaScript/TypeScript Nightly Extension to stay on the bleeding edge (which is typically very stable).
Visual Studio 2017/2019 have [the SDK installers above] and MSBuild installs.
Sublime Text 3 supports selecting different versions of TypeScript
You can check out a partial list of editors that have support for TypeScript to learn more about whether your favorite editor has support to use new versions.</p>
<p>Convert to Optional Chaining
Optional chaining is a recent feature that’s received a lot of love. That’s why TypeScript 4.0 brings a new refactoring to convert common patterns to take advantage of optional chaining and nullish coalescing!</p>
<p>Converting <code>a &amp;&amp; a.b.c &amp;&amp; a.b.c.d.e.f()</code> to <code>a?.b.c?.d.e.f.()</code></p>
<p>Keep in mind that while this refactoring doesn’t perfectly capture the same behavior due to subtleties with truthiness/falsiness in JavaScript, we believe it should capture the intent for most use-cases, especially when TypeScript has more precise knowledge of your types.</p>
<p>For more details, check out the pull request for this feature.</p>
<p>/** @deprecated */ Support
TypeScript’s editing support now recognizes when a declaration has been marked with a /** @deprecated * JSDoc comment. That information is surfaced in completion lists and as a suggestion diagnostic that editors can handle specially. In an editor like VS Code, deprecated values are typically displayed a strike-though style like this.</p>
<p>Some examples of deprecated declarations with strikethrough text in the editor</p>
<p>This new functionality is available thanks to Wenlu Wang. See the pull request for more details.</p>
<p>Partial Semantic Mode at Startup
We’ve heard a lot from users suffering from long startup times, especially on bigger projects. The culprit is usually a process called program construction. This is the process of starting with an initial set of root files, parsing them, finding their dependencies, parsing those dependencies, finding those dependencies’ dependencies, and so on. The bigger your project is, the longer you’ll have to wait before you can get basic editor operations like go-to-definition or quick info.</p>
<p>That’s why we’ve been working on a new mode for editors to provide a partial experience until the full language service experience has loaded up. The core idea is that editors can run a lightweight partial server that only looks at the current files that the editor has open.</p>
<p>It’s hard to say precisely what sorts of improvements you’ll see, but anecdotally, it used to take anywhere between 20 seconds to a minute before TypeScript would become fully responsive on the Visual Studio Code codebase. In contrast, our new partial semantic mode seems to bring that delay down to just a few seconds. As an example, in the following video, you can see two side-by-side editors with TypeScript 3.9 running on the left and TypeScript 4.0 running on the right.</p>
<p>When restarting both editors on a particularly large codebase, the one with TypeScript 3.9 can’t provide completions or quick info at all. On the other hand, the editor with TypeScript 4.0 can immediately give us a rich experience in the current file we’re editing, despite loading the full project in the background.</p>
<p>Currently the only editor that supports this mode is Visual Studio Code which has some UX improvements coming up in Visual Studio Code Insiders. We recognize that this experience may still have room for polish in UX and functionality, and we have a list of improvements in mind. We’re looking for more feedback on what you think might be useful.</p>
<p>For more information, you can see the original proposal, the implementing pull request, along with the follow-up meta issue.</p>
<p>Smarter Auto-Imports
Auto-import is a fantastic feature that makes coding a lot easier; however, every time auto-import doesn’t seem to work, it can throw users off a lot. One specific issue that we heard from users was that auto-imports didn’t work on dependencies that were written in TypeScript - that is, until they wrote at least one explicit import somewhere else in their project.</p>
<p>Why would auto-imports work for @types packages, but not for packages that ship their own types? It turns out that auto-imports only work on packages your project already includes. Because TypeScript has some quirky defaults that automatically add packages in node_modules/@types to your project, those packages would be auto-imported. On the other hand, other packages were excluded because crawling through all your node_modules packages can be really expensive.</p>
<p>All of this leads to a pretty lousy getting started experience for when you’re trying to auto-import something that you’ve just installed but haven’t used yet.</p>
<p>TypeScript 4.0 now does a little extra work in editor scenarios to include the packages you’ve listed in your package.json’s dependencies (and peerDependencies) fields. The information from these packages is only used to improve auto-imports, and doesn’t change anything else like type-checking. This allows us to provide auto-imports for all of your dependencies that have types, without incurring the cost of a complete node_modules search.</p>
<p>In the rare cases when your package.json lists more than ten typed dependencies that haven’t been imported yet, this feature automatically disables itself to prevent slow project loading. To force the feature to work, or to disable it entirely, you should be able to configure your editor. For Visual Studio Code, this is the “Include Package JSON Auto Imports” (or typescript.preferences.includePackageJsonAutoImports) setting.</p>
<p>Configuring &lsquo;include package JSON auto imports&rsquo; For more details, you can see the proposal issue along with the implementing pull request.</p>
<p>Our New Website!
The TypeScript website has recently been rewritten from the ground up and rolled out!</p>
<p>A screenshot of the new TypeScript website</p>
<p>We already wrote a bit about our new site, so you can read up more there; but it’s worth mentioning that we’re still looking to hear what you think! If you have questions, comments, or suggestions, you can file them over on the website’s issue tracker.</p>
<p>Breaking Changes
lib.d.ts Changes
Our lib.d.ts declarations have changed - most specifically, types for the DOM have changed. The most notable change may be the removal of document.origin which only worked in old versions of IE and Safari MDN recommends moving to self.origin.</p>
<p>Properties Overriding Accessors (and vice versa) is an Error
Previously, it was only an error for properties to override accessors, or accessors to override properties, when using useDefineForClassFields; however, TypeScript now always issues an error when declaring a property in a derived class that would override a getter or setter in the base class.</p>
<p>class Base {
get foo() {
return 100;
}
set foo(value) {
// &hellip;
}
}</p>
<p>class Derived extends Base {
foo = 10;
&lsquo;foo&rsquo; is defined as an accessor in class &lsquo;Base&rsquo;, but is overridden here in &lsquo;Derived&rsquo; as an instance property.
}
class Base {
prop = 10;
}</p>
<p>class Derived extends Base {
get prop() {
&lsquo;prop&rsquo; is defined as a property in class &lsquo;Base&rsquo;, but is overridden here in &lsquo;Derived&rsquo; as an accessor.
return 100;
}
}
See more details on the implementing pull request.</p>
<p>Operands for delete must be optional.
When using the delete operator in strictNullChecks, the operand must now be any, unknown, never, or be optional (in that it contains undefined in the type). Otherwise, use of the delete operator is an error.</p>
<p>interface Thing {
prop: string;
}</p>
<p>function f(x: Thing) {
delete x.prop;
The operand of a &lsquo;delete&rsquo; operator must be optional.
}
See more details on the implementing pull request.</p>
<p>Usage of TypeScript’s Node Factory is Deprecated
Today TypeScript provides a set of “factory” functions for producing AST Nodes; however, TypeScript 4.0 provides a new node factory API. As a result, for TypeScript 4.0 we’ve made the decision to deprecate these older functions in favor of the new ones.</p>
<p>For more details, read up on the relevant pull request for this change.</p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://choy-mutao.github.io/images/user.png" alt="Author image" nopin="nopin" />
        
        
            Choy
        
        
        <time class="post-date" datetime="0001-01-01T00:00:00Z">
            1 Jan 0001
        </time>
    </footer>
</article>

    
        
<article class="post Basic">
    <header class="post-header">
        <h2 class="post-title"><a href="/basic/typescript/promise/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h1 id="promise">Promise</h1>
<h2 id="chain">Chain</h2>
<p><img src="./assets/promise_chain.png" alt="Promise Chain"></p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://choy-mutao.github.io/images/user.png" alt="Author image" nopin="nopin" />
        
        
            Choy
        
        
        <time class="post-date" datetime="0001-01-01T00:00:00Z">
            1 Jan 0001
        </time>
    </footer>
</article>

    
        
<article class="post Basic">
    <header class="post-header">
        <h2 class="post-title"><a href="/basic/typescript/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E6%96%B9%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h1 id="箭头函数和普通方程函数的区别">箭头函数和普通方程函数的区别</h1>
<ol>
<li>箭头函数做类型的时候，是一个联合类型
Function type notation must be parenthesized when used in a union type</li>
</ol>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://choy-mutao.github.io/images/user.png" alt="Author image" nopin="nopin" />
        
        
            Choy
        
        
        <time class="post-date" datetime="0001-01-01T00:00:00Z">
            1 Jan 0001
        </time>
    </footer>
</article>

    
        
<article class="post Basic">
    <header class="post-header">
        <h2 class="post-title"><a href="/basic/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%9C%AF/chapter0/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h1 id="序">序</h1>
<p>昔在<code>庖犠氏</code>始画<code>八卦</code>，以通神明之德，以类万物之情，作九九之数，以合六爻之变。暨于黄帝神而化之，引而伸之，于是建历纪，协律吕，用稽道原，然后 <code>两仪四象</code>精微之气可得而效焉。记称隶首作数，其详未之闻也。按周公制礼而有<code>九数</code>，九数之流，则《九章》是矣。往者暴秦焚书，经术散坏。自时厥后，汉北 平侯<code>张苍</code>、大司农中丞<code>耿寿昌</code>皆以善算命世。苍等因<code>旧文之遗残</code>，各称删补。故 校其目则与古或异，而所论者多近语也。徽幼习 《九章》，长再详览。观陰陽之 割裂，总算术之根源，探赜之暇，遂悟其意。是以敢竭顽鲁，采其所见，为之作 注。事类相推，各有攸归，故枝条虽分而同本榦知，发其一端而已。又所析理以 辞，解体用图，庶亦约而能周，通而不黩，览之者思过半矣。且算在六艺，古者 以宾兴贤能，教习 国子；虽曰九数，其能穷纤入微，探测无方；至于以法相传， 亦犹规矩度量可得而共，非特难为也。当今好之者寡，故世虽多通才达学，而未 必能综于此耳。《周官·大司徒》职，夏至日中立八尺之表。其景尺有五寸，谓 之地中。说云，南戴日下万五千里。夫云尔者，以术推之。案：《九章》立四表 望远及因木望山之术，皆端旁互见，无有超邈若斯之类。然则苍等为术犹未足以 博尽群数也。徽寻九数有重差之名，原其指趣乃所以施于此也。凡望极高、测绝 深而兼知其远者必用重差、句股，则必以重差为率，故曰重差也。立两表于洛陽 之城，令高八尺，南北各尽平地。同日度其正中之时。以景差为法，表高乘表间 为实，实如法而一。所得加表高，即日去地也。以南表之景乘表间为实，实如法 而一，即为从南表至南戴日下也。以南戴日下及日去地为句、股，为之求弦，即 日去人也。以径寸之筒南望日，日满筒空，则定筒之长短以为股率，以筒径为句 率，日去人之数为大股，大股之句即日径也。虽夫圆穹之象犹曰可度，又况泰山 之高与江 海之广哉。徽以为今之史籍且略举天地之物，考论厥数，载之于志，以 阐世术之美，辄造《重差》，并为注解，以究古人之意，缀于句股之下。度高者 重表，测深者累矩，孤离者三望，离而又旁求者四望。触类而长之，则虽幽遐诡 伏，靡所不入，博物君子，详而览焉。</p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://choy-mutao.github.io/images/user.png" alt="Author image" nopin="nopin" />
        
        
            Choy
        
        
        <time class="post-date" datetime="0001-01-01T00:00:00Z">
            1 Jan 0001
        </time>
    </footer>
</article>

    
        
<article class="post Basic">
    <header class="post-header">
        <h2 class="post-title"><a href="/basic/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%9C%AF/chapter1/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h1 id="卷一">卷一</h1>
<p>○方田（以御田畴界域） 今有田广十五步，从十六步。问为田几何？答曰：一亩。</p>
<p>又有田广十二步，从十四步。问为田几何？答曰：一百六十八步。</p>
<p>〔图：从十四，广十二。〕 方田术曰：广从步数相乘得积步。</p>
<p>〔此积谓田幂。凡广从相乘谓之幂。</p>
<p>淳风等按：经云广从相乘得积步，注云广从相乘谓之幂。观斯注意，积幂义 同。以理推之，固当不尔。何则？幂是方面单布之名，积乃众数聚居之称。循名 责实，二者全殊。虽欲同之，窃恐不可。今以凡言幂者据广从之一方；其言积者 举众步之都数。经云相乘得积步，即是都数之明文。注云谓之为幂，全乖积步之 本意。此注前云积为田幂，于理得通。复云谓之为幂，繁而不当。今者注释，存 善去非，略为料简，遗诸后学。〕 以亩法二百四十步除之，即亩数。百亩为一顷。</p>
<p>〔淳风等按：此为篇端，故特举顷、亩二法。余术不复言者，从此可知。一 亩之田，广十五步，从而疏之，令为十五行，则每行广一步而从十六步。又横而 截之，令为十六行，则每行广一步而从十五步。此即从疏横截之步，各自为方， 凡有二百四十步。一亩之地，步数正同。以此言之，则广从相乘得积步，验矣。</p>
<p>二百四十步者，亩法也；百亩者，顷法也。故以除之，即得。〕 今有田广一里，从一里。问为田几何？答曰：三顷七十五亩。</p>
<p>又有田广二里，从三里。问为田几何？答曰：二十二顷五十亩。</p>
<p>里田术曰：广从里数相乘得积里。以三百七十五乘之，即亩数。</p>
<p>〔按：此术广从里数相乘得积里。方里之中有三顷七十五亩，故以乘之，即 得亩数也。〕 今有十八分之十二，问约之得几何？答曰：三分之二。</p>
<p>又有九十一分之四十九，问约之得几何？答曰：十三分之七。</p>
<p>○约分 〔按：约分者，物之数量，不可悉全，必以分言之；分之为数，繁则难用。</p>
<p>设有四分之二者，繁而言之，亦可为八分之四；约而言之，则二分之一也，虽则 异辞，至于为数，亦同归尔。法实相推，动有参差，故为术者先治诸分。〕 术曰：可半者半之；不可半者，副置分母、子之数，以少减多，更相减损， 求其等也。以等数约之。</p>
<p>〔等数约之，即除也。其所以相减者，皆等数之重叠，故以等数约之。〕 今有三分之一，五分之二，问合之得几何？答曰：十五分之十一。</p>
<p>又有三分之二，七分之四，九分之五，问合之得几何？答曰：得一、六十三 分之五十。</p>
<p>又有二分之一，三分之二，四分之三，五分之四，问合之得几何？答曰：得 二、六十分之四十三。</p>
<p>○合分 〔淳风等按：合分知，数非一端，分无定准，诸分子杂互，群母参差。粗细 既殊，理难从一，故齐其众分，同其群母，令可相并，故曰合分。〕 术曰：母互乘子，并以为实。母相乘为法。</p>
<p>〔母互乘子。约而言之者，其分粗；繁而言之者，其分细。虽则粗细有殊， 然其实一也。众分错杂，非细不会。乘而散之，所以通之。通之则可并也。凡母 互乘子谓之齐，群母相乘谓之同。同者，相与通同，共一母也；齐者，子与母齐， 势不可失本数也。方以类聚，物以群分。数同类者无远；数异类者无近。远而通 体知，虽异位而相从也；近而殊形知，虽同列而相违也。然则齐同之术要矣：错 综度数，动之斯谐，其犹佩觿解结，无往而不理焉。乘以散之，约以聚之，齐同 以通之，此其算之纲纪乎？其一术者，可令母除为率，率乘子为齐。〕 实如法而一。不满法者，以法命之。</p>
<p>〔今欲求其实，故齐其子，又同其母，令如母而一。其余以等数约之，即得 知，所谓同法为母，实余为子，皆从此例。〕 其母同者，直相从之。</p>
<p>今有九分之八，减其五分之一，问余几何？答曰：四十五分之三十一。</p>
<p>又有四分之三，减其三分之一，问余几何？答曰：十二分之五。</p>
<p>○减分 〔淳风等按：诸分子、母数各不同，以少减多，欲知余几，减余为实，故曰 减分。〕 术曰：母互乘子，以少减多，余为实。母相乘为法。实如法而一。</p>
<p>〔母互乘子知，以齐其子也。以少减多知，齐故可相减也。母相乘为法者， 同其母也。母同子齐，故如母而一，即得。〕 今有八分之五，二十五分之十六，问孰多？多几何？答曰：二十五分之十六 多，多二百分之三。</p>
<p>又有九分之八，七分之六，问孰多？多几何？答曰：九分之八多，多六十三 分之二。</p>
<p>又有二十一分之八，五十分之十七，问孰多？多几何？答曰：二十一分之八 多，多一千五十分之四十三。</p>
<p>○课分 〔淳风等按：分各异名，理不齐一，较其相近之数，故曰课分也。〕 术曰：母互乘子，以少减多，余为实。母相乘为法。实如法而一，即相多也。</p>
<p>〔淳风等按：此术母互乘子，以少分减多分，与减分义同；惟相多之数，意 与减分有异：减分知，求其余数有几；课分知，以其余数相多也。〕 今有三分之一，三分之二，四分之三。问减多益少，各几何而平？答曰：减 四分之三者二，三分之二者一，并，以益三分之一，而各平于十二分之七。</p>
<p>又有二分之一，三分之二，四分之三。问减多益少，各几何而平？答曰：减 三分之二者一，四分之三者四、并，以益二分之一，而各平于三十六分之二十三。</p>
<p>○平分 〔淳风等按：平分知，诸分参差，欲令齐等，减彼之多，增此之少，故曰平 分也。〕 术曰：母互乘子， 〔齐其子也。〕 副并为平实。</p>
<p>〔淳风等按：母互乘子，副并为平实知，定此平实主限，众子所当损益知， 限为平。〕 母相乘为法。</p>
<p>〔母相乘为法知，亦齐其子，又同其母。〕 以列数乘未并者各自为列实。亦以列数乘法。</p>
<p>〔此当副置列数除平实，若然则重有分，故反以列数乘同齐。</p>
<p>淳风等按：问云所平之分多少不定，或三或二，列位无常。平三知，置位三 重；平二知，置位二重。凡此之例，一准平分不可豫定多少，故直云列数而已。〕 以平实减列实，余，约之为所减。并所减以益于少。以法命平实，各得其平。</p>
<p>今有七人，分八钱三分钱之一。问人得几何？答曰：人得一钱二十一分钱之 四。</p>
<p>又有三人三分人之一，分六钱三分钱之一、四分钱之三。问人得几何？答曰： 人得二钱八分钱之一。</p>
<p>○经分 〔淳风等按：经分者，自合分已下，皆与诸分相齐，此乃直求一人之分。以 人数分所分，故曰经分也。〕 术曰：以人数为法，钱数为实，实如法而一。有分者通之。</p>
<p>〔母互乘子知，齐其子；母相乘者，同其母。以母通之者，分母乘全内子。</p>
<p>乘，散全则为积分，积分则与子相通，故可令相从。凡数相与者谓之率。率知， 自相与通。有分则可散，分重叠则约也；等除法实，相与率也。故散分者，必令 两分母相乘法实也。〕 重有分者同而通之。</p>
<p>〔又以法分母乘实，实分母乘法。此谓法、实俱有分，故令分母各乘全分内 子，又令分母互乘上下。〕 今有田广七分步之四，从五分步之三，问为田几何？答曰：三十五分步之十 二。</p>
<p>又有田广九分步之七，从十一分步之九，问为田几何？答曰：十一分步之七。</p>
<p>又有田广五分步之四，从九分步之五，问为田几何？答曰：九分步之四。</p>
<p>○乘分 〔淳风等按：乘分者，分母相乘为法，子相乘为实，故曰乘分。〕 术曰：母相乘为法，子相乘为实，实如法而一。</p>
<p>〔凡实不满法者而有母、子之名。若有分，以乘其实而长之，则亦满法，乃 为全耳。又以子有所乘，故母当报除。报除者，实如法而一也。今子相乘则母各 当报除，因令分母相乘而连除也。此田有广从，难以广谕。设有问者曰：马二十 匹，直金十二斤。今卖马二十匹，三十五人分之，人得几何？答曰：三十五分斤 之十二。其为之也，当如经分术，以十二斤金为实，三十五人为法。设更言马五 匹，直金三斤。今卖马四匹，七人分之，人得几何？答曰：人得三十五分斤之十 二。其为之也，当齐其金、人之数，皆合初问入于经分矣。然则分子相乘为实者， 犹齐其金也；母相乘为法者，犹齐其人也。同其母为二十，马无事于同，但欲求 齐而已。又，马五匹，直金三斤，完全之率；分而言之，则为一匹直金五分斤之 三。七人卖四马，一人卖七分马之四。金与人交 互相生。所从言之异，而计数则 三术同归也。〕 今有田广三步三分步之一，从五步五分步之二，问为田几何？答曰：十八步。</p>
<p>又有田广七步四分步之三，从十五步九分步之五，问为田几何？答曰：一百 二十步九分步之五。</p>
<p>又有田广十八步七分步之五，从二十三步十一分步之六，问为田几何？答曰： 一亩二百步十一分步之七。</p>
<p>○大广田 〔淳风等按：大广田知，初术直有全步而无余分；次术空有余分而无全步； 此术先见全步，复有余分，可以广兼三术，故曰大广。〕 术曰：分母各乘其全，分子从之， 〔分母各乘其全，分子从之者，通全步内分子。如此则母、子皆为实矣。〕 相乘为实。分母相乘为法。</p>
<p>〔犹乘分也。〕 实如法而一。</p>
<p>〔今为术广从俱有分，当各自通其分。命母入者，还须出之，故令分母相乘 为法而连除之。〕 今有圭田广十二步，正从二十一步，问为田几何？答曰：一百二十六步。</p>
<p>又有圭田广五步二分步之一，从八步三分步之二，问为田几何？答曰：二十 三步六分步之五。</p>
<p>术曰：半广以乘正从。</p>
<p>〔半广知，以盈补虚为直田也。亦可半正从以乘广。按：半广乘从，以取中 平之数，故广从相乘为积步。亩法除之，即得也。〕 今有邪田，一头广三十步，一头广四十二步，正从六十四步。问为田几何？ 答曰：九亩一百四十四步。</p>
<p>又有邪田，正广六十五步，一畔从一百步，一畔从七十二步。问为田几何？ 答曰：二十三亩七十步。</p>
<p>术曰：并两斜而半之，以乘正从若广。又可半正从若广，以乘并。亩法而一。</p>
<p>〔并而半之者，以盈补虚也。〕 今有箕田，舌广二十步，踵广五步，正从三十步，问为田几何？答曰：一亩 一百三十五步。</p>
<p>又有箕田，舌广一百一十七步，踵广五十步，正从一百三十五步，问为田几 何？答曰：四十六亩二百三十二步半。</p>
<p>术曰：并踵、舌而半之，以乘正从。亩法而一。</p>
<p>〔中分箕田则为两邪田，故其术相似。又可并踵、舌，半正从，以乘之。〕 今有圆田，周三十步，径十步。</p>
<p>〔淳风等按：术意以周三径一为率，周三十步，合径十步。今依密率，合径 九步十一分步之六。〕 问为田几何？答曰：七十五步。</p>
<p>〔此于徽术，当为田七十一步一百五十七分步之一百三。</p>
<p>淳风等按：依密率，为田七十一步二十三分步之一十三。〕 又有圆田，周一百八十一步，径六十步三分步之一。</p>
<p>〔淳风等按：周三径一，周一百八十一步，径六十步三分步之一。依密率， 径五十七步二十二分步之一十三。〕 问为田几何？答曰：十一亩九十步十二分步之一。</p>
<p>〔此于徽术，当为田十亩二百八步三百一十四分步之一百十三。</p>
<p>淳风等按：依密率，当为田十亩二百五步八十八分步之八十七。〕 术曰：半周半径相乘得积步。</p>
<p>〔按：半周为从，半径为广，故广从相乘为积步也。假令圆径二尺，圆中容 六觚之一面，与圆径之半，其数均等。合径率一而外周率三也。</p>
<p>又按：为图，以六觚之一面乘一弧半径，三之，得十二觚之幂。若又割之， 次以十二觚之一面乘一弧之半径，六之，则得二十四觚之幂。割之弥细，所失弥 少。割之又割，以至于不可割，则与圆周合体而无所失矣。觚面之外，又有余径。</p>
<p>以面乘余径，则幂出觚表。若夫觚之细者，与圆合体，则表无余径。表无余径， 则幂不外出矣。以一面乘半径，觚而裁之，每辄自倍。故以半周乘半径而为圆幂。</p>
<p>此一周、径，谓至然之数，非周三径一之率也。周三者，从其六觚之环耳。以推 圆规多少之觉，乃弓之与弦也。然世传此法，莫肯精核；学者踵古，习 其谬失。</p>
<p>不有明据，辩之斯难。凡物类形象，不圆则方。方圆之率，诚著于近，则虽远可 知也。由此言之，其用博矣。谨按图验，更造密率。恐空设法，数昧而难譬，故 置诸检括，谨详其记注焉。</p>
<p>割六觚以为十二觚术曰：置圆径二尺，半之为一尺，即圆里觚之面也。令 半径一尺为弦，半面五寸为句，为之求股。以句幂二十五寸减弦幂，余七十五寸， 开方除之，下至秒、忽。又一退法，求其微数。微数无名知以为分子，以十为分 母，约作五分忽之二。故得股八寸六分六厘二秒五忽五分忽之二。以减半径，余 一寸三分三厘九毫七秒四忽五分忽之三，谓之小句。觚之半面又谓之小股。为之 求弦。其幂二千六百七十九亿四千九百一十九万三千四百四十五忽，余分弃之。</p>
<p>开方除之，即十二觚之一面也。</p>
<p>割十二觚以为二十四觚术曰：亦令半径为弦，半面为句，为之求股。置上 小弦幂，四而一，得六百六十九亿八千七百二十九万八千三百六十一忽，余分弃之， 即句幂也。以减弦幂，其余开方除之，得股九寸六分五厘九毫二秒五忽五分忽之 四。以减半径，余三分四厘七秒四忽五分忽之一，谓之小句。觚之半面又谓之小 股。为之求小弦。其幂六百八十一亿四千八百三十四万九千四百六十六忽，余分 弃之。开方除之，即二十四觚之一面也。</p>
<p>割二十四觚以为四十八觚术曰：亦令半径为弦，半面为句，为之求股。置上 小弦幕，四而一，得一百七十亿三千七百八万七千三百六十六忽，余分弃之，即 句幂也。以减弦幂，其余，开方除之，得股九寸九分一厘四毫四秒四忽五分忽之 四。以减半径，余八厘五毫五秒五忽五分忽之一，谓之小句。觚之半面又谓之小 股。为之求小弦。其幂一百七十一亿一千二十七万八千八百一十三忽，余分弃之。</p>
<p>开方除之，得小弦一寸三分八毫六忽，余分弃之，即四十八觚之一面。以半径一 尺乘之，又以二十四乘之，得幂三万一千三百九十三亿四千四百万忽。以百亿除 之，得幂三百一十三寸六百二十五分寸之五百八十四，即九十六觚之幂也。</p>
<p>割四十八觚以为九十六觚术曰：亦令半径为弦，半面为句，为之求股。置次 上弦幂，四而一，得四十二亿七千七百五十六万九千七百三忽，余分弃之，即句 幂也。以减弦幂，其余，开方除之，得股九寸九分七厘八毫五秒八忽十分忽之九。</p>
<p>以减半径，余二厘一毫四秒一忽十分忽之一，谓之小句。觚之半面又谓之小股。</p>
<p>为之求小弦。其幂四十二亿八千二百一十五万四千一十二忽，余分弃之。开方除 之，得小弦六分五厘四毫三秒八忽，余分弃之，即九十六觚之一面。以半径一尺 乘之，又以四十八乘之，得幂三万一千四百一十亿二千四百万忽，以百亿除之， 得幂三百一十四寸六百二十五分寸之六十四，即一百九十二觚之幂也。以九十六 觚之幂减之，余六百二十五分寸之一百五，谓之差幂。倍之，为分寸之二百一十， 即九十六觚之外弧田九十六所，谓以弦乘矢之凡幂也。加此幂于九十六觚之幂， 得三百一十四寸六百二十五分寸之一百六十九，则出圆之表矣。故还就一百九十 二觚之全幂三百一十四寸以为圆幂之定率而弃其余分。以半径一尺除圆幂，倍之， 得六尺二寸八分，即周数。令径自乘为方幂四百寸，与圆幂相折，圆幂得一百五 十七为率，方幂得二百为率。方幂二百其中容圆幂一百五十七也。圆率犹为微少。</p>
<p>案：弧田图令方中容圆，圆中容方，内方合外方之半。然则圆幂一百五十七，其 中容方幂一百也。又令径二尺与周六尺二寸八分相约，周得一百五十七，径得五 十，则其相与之率也。周率犹为微少也。晋武库中汉时王莽作铜斛，其铭曰：律 嘉量斛，内方尺而圆其外，庣旁九厘五毫，幂一百六十二寸，深一尺，积一千六 百二十寸，容十斗。以此术求之，得幂一百六十一寸有奇，其数相近矣。此术微 少。而觚差幂六百二十五分寸之一百五。以一百九十二觚之幂为率消息，当取此 分寸之三十六，以增于一百九十二觚之幂，以为圆幂，三百一十四寸二十五分寸 之四。置径自乘之方幂四百寸，令与圆幂通相约，圆幂三千九百二十七，方幂得 五千，是为率。方幂五千中容圆幂三千九百二十七；圆幂三千九百二十七中容方 幂二千五百也。以半径一尺除圆幂三百一十四寸二十五分寸之四，倍之，得六尺 二寸八分二十五分分之八，即周数也。全径二尺与周数通相约，径得一千二百五 十，周得三千九百二十七，即其相与之率。若此者，盖尽其纤微矣。举而用之， 上法仍约耳。当求一千五百三十六觚之一面，得三千七十二觚之幂，而裁其微分， 数亦宜然，重其验耳。</p>
<p>淳风等案：旧术求圆，皆以周三径一为率。若用之求圆周之数，则周少径多。</p>
<p>用之求其六觚之田，乃与此率合会耳。何则？假令六觚之田，觚间各一尺为面， 自然从角至角，其径二尺可知。此则周六径二与周三径一已合。恐此犹为难晓， 今更引物为喻。设令刻物作圭形者六枚，枚别三面，皆长一尺。攒此六物，悉使 锐头向里，则成六觚之周，角径亦皆一尺。更从觚角外畔，围绕为规，则六觚之 径尽达规矣。当面径短，不至外规。若以径言之，则为规六尺，径二尺，面径皆 一尺。面径股不至外畔，定无二尺可知。故周三径一之率于圆周乃是径多周少。</p>
<p>径一周三，理非精密。盖术从简要，举大纲，略而言之。刘徽特以为疏，遂改张 其率。但周、径相乘，数难契合。徽虽出斯二法，终不能究其纤毫也。祖冲之以 其不精，就中更推其数。今者修撰，捃摭诸家，考其是非，冲之为密。故显之于 徽术之下，冀学者知所裁焉。〕 又术曰：周、径相乘，四而一。</p>
<p>〔此周与上觚同耳。周、径相乘，各当一半。而今周、径两全，故两母相乘 为四，以报除之。于徽术，以五十乘周，一百五十七而一，即径也。以一百五十 七乘径，五十而一，即周也。新术径率犹当微少。据周以求径，则失之长；据径 以求周，则失之短。诸据见径以求幂者，皆失之于微少；据周以求幂者，皆失之 于微多。</p>
<p>淳风等按：依密率，以七乘周，二十二而一，即径；以二十二乘径，七而一， 即周。依术求之，即得。〕 又术曰：径自相乘，三之，四而一。</p>
<p>〔按：圆径自乘为外方，三之，四而一者，是为圆居外方四分之三也。若令 六觚之一面乘半径，其幂即外方四分之一也。因而三之，即亦居外方四分之三也。</p>
<p>是为圆里十二觚之幂耳。取以为圆，失之于微少。于徽新术，当径自乘，又以一 百五十七乘之，二百而一。</p>
<p>淳风等按：密率，令径自乘，以十一乘之，十四而一，即圆幂也。〕 又术曰：周自相乘，十二而一。</p>
<p>〔六觚之周，其于圆径，三与一也。故六觚之周自相乘为幂，若圆径自乘者 九方。九方凡为十二觚者十有二，故曰十二而一，即十二觚之幂也。今此令周自 乘，非但若为圆径自乘者九方而已。然则十二而一，所得又非十二觚之幂也。若 欲以为圆幂，失之于多矣。以六觚之周，十二而一可也。于徽新术，直令圆周自 乘，又以二十五乘之，三百一十四而一，得圆幂。其率：二十五者，周幂也；三 百一十四者，周自乘之幂也。置周数六尺二寸八分，令自乘，得幂三十九万四千 三百八十四分。又置圆幂三万一千四百分。皆以一千二百五十六约之，得此率。</p>
<p>淳风等按：方面自乘即得其积。圆周求其幂，假率乃通。但此术所求用三、 一为率。圆田正法，半周及半径以相乘。今乃用全周自乘，故须以十二为母。何 者？据全周而求半周，则须以二为法。就全周而求半径，复假六以除之。是二、 六相乘，除周自乘之数。依密率，以七乘之，八十八而一。〕 今有宛田，下周三十步，径十六步。问为田几何？答曰：一百二十步。</p>
<p>又有宛田，下周九十九步，径五十一步。问为田几何？答曰：五亩六十二步 四分步之一。</p>
<p>术曰：以径乘周，四而一。</p>
<p>〔此术不验，故推方锥以见其形。假令方锥下方六尺，高四尺。四尺为股， 下方之半三尺为句。正面邪为弦，弦五尺也。令句弦相乘，四因之，得六十尺， 即方锥四面见者之幂。若令其中容圆锥，圆锥见幂与方锥见幂，其率犹方幂之与 圆幂也。按：方锥下六尺，则方周二十四尺。以五尺乘而半之，则亦锥之见幂。</p>
<p>故求圆锥之数，折径以乘下周之半，即圆锥之幂也。今宛田上径圆穹，而与圆锥 同术，则幂失之于少矣。然其术难用，故略举大较，施之大广田也。求圆锥之幂， 犹求圆田之幂也。今用两全相乘，故以四为法，除之，亦如圆田矣。开立圆术说 圆方诸率甚备，可以验此。〕 今有弧田，弦二十步，矢十五步。问为田几何？答曰：一亩九十七步半。</p>
<p>又有弧田，弦七十八步二分步之一，矢十三步九分步之七。问为田几何？答 曰：二亩一百五十五步八十一分步之五十六。</p>
<p>术曰：以弦乘矢，矢又自乘，并之，二而一。</p>
<p>〔方中之圆，圆里十二觚之幂，合外方之幂四分之三也。中方合外方之半， 则朱青合外方四分之一也。弧田，半圆之幂也。故依半圆之体而为之术。以弦乘 矢而半之，则为黄幂，矢自乘而半之，则为二青幂。青、黄相连为弧体，弧体法 当应规。今觚面不至外畔，失之于少矣。圆田旧术以周三径一为率，俱得十二觚 之幂，亦失之于少也，与此相似。指验半圆之幂耳。若不满半圆者，益复疏阔。</p>
<p>宜句股锯圆材之术，以弧弦为锯道长，以矢为锯深，而求其径。既知圆径，则弧 可割分也。割之者，半弧田之弦以为股，其矢为句，为之求弦，即小弧之弦也。</p>
<p>以半小弧之弦为句，半圆径为弦，为之求股。以减半径，其余即小弦之矢也。割 之又割，使至极细。但举弦、矢相乘之数，则必近密率矣。然于算数差繁，必欲 有所寻究也。若但度田，取其大数，旧术为约耳。〕 今有环田，中周九十二步，外周一百二十二步，径五步。</p>
<p>〔此欲令与周三径一之率相应，故言径五步也。据中、外周，以徽术言之， 当径四步一百五十七分步之一百二十二也。</p>
<p>淳风等按：依密率，合径四步二十二分步之十七。〕 问为田几何？答曰：二亩五十五步。</p>
<p>〔于徽术，当为田二亩三十一步一百五十七分步之二十三。</p>
<p>淳风等按：依密率，为田二亩三十步二十二分步之十五。〕 术曰：并中、外周而半之，以径乘之，为积步。</p>
<p>〔此田截而中之周则为长。并而半之知，亦以盈补虚也。此可令中、外周各 自为圆田，以中圆减外圆，余则环实也。〕 又有环田，中周六十二步四分步之三，外周一百一十三步二分步之一，径十 二步三分步之二。</p>
<p>〔此田环而不通匝，故径十二步三分步之二。若据上周求径者，此径失之于 多，过周三径一之率，盖为疏矣。于徽术，当径八步六百二十八分步之五十一。</p>
<p>淳风等按：依周三径一考之，合径八步二十四分步之一十一。依密率，合径 八步一百七十六分步之一十三。〕 问为田几何？答曰：四亩一百五十六步四分步之一。</p>
<p>〔于徽术，当为田二亩二百三十二步五千二十四分步之七百八十七也。依周 三径一，为田三亩二十五步六十四分步之二十五。</p>
<p>淳风等按：密率，为田二亩二百三十一步一千四百八分步之七百一十七也。〕 术曰：置中、外周步数，分母子各居其下。母互乘子，通全步内分子。以中 周减外周，余半之，以益中周。径亦通分内子，以乘周为实。分母相乘为法。除 之为积步。余，积步之分。以亩法除之，即亩数也。</p>
<p>〔按：此术，并中、外周步数于上，分母子于下，母互乘子者，为中外周俱 有余分，故以互乘齐其子，母相乘同其母。子齐母同，故通全步，内分子。半之 知，以盈补虚，得中平之周。周则为从，径则为广，故广从相乘而得其积。既合 分母，还须分母出之。故令周、径分母相乘而连除之，即得积步。不尽，以等数 除之而命分。以亩法除积步，得亩数也。〕</p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://choy-mutao.github.io/images/user.png" alt="Author image" nopin="nopin" />
        
        
            Choy
        
        
        <time class="post-date" datetime="0001-01-01T00:00:00Z">
            1 Jan 0001
        </time>
    </footer>
</article>

    
        
<article class="post Basic">
    <header class="post-header">
        <h2 class="post-title"><a href="/basic/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%9C%AF/chapter2/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h1 id="卷二">卷二</h1>
<p>○ 粟米（以御交 质变易） 粟米之法 〔凡此诸率相与大通，其时相求，各如本率。可约者约之。别术然也。〕 粟率五十大抃五十四稻六十 粝米三十粝饭七十五豉六十三 粺米二十七粺饭五十四飧九十 米二十四饭四十八熟菽一百三半 御米二十一御饭四十二糵一百七十五 小&lt;麦啇&gt;十三半菽荅麻麦各四十五 今有 〔此都术也。凡九数以为篇名，可以广施诸率。所谓告往而知来，举一隅而 三隅反者也。诚能分诡数之纷杂，通彼此之否塞，因物成率，审辨名分，平其偏 颇，齐其参差，则终无不归于此术也。〕 术曰：以所有数乘所求率为实。以所有率为法。</p>
<p>〔少者多之始，一者数之母，故为率者必等之于一。据粟率五、粝率三，是 粟五而为一，粝米三而为一也。欲化粟为米者，粟当先本是一。一者，谓以五约 之，令五而为一也。讫，乃以三乘之，令一而为三。如是，则率至于一，以五为 三矣。然先除后乘，或有余分，故术反之。又完言之知，粟五升为粝米三升；以 分言之知，粟一斗为粝米五分斗之三，以五为母，三为子。以粟求粝米者，以子 乘，其母报除也。然则所求之率常为母也。</p>
<p>淳风等按：“宜云所求之率常为子，所有之率常为母。”今乃云“所求之率 常为母”知，脱错也。〕 实如法而一。</p>
<p>今有粟一斗，欲为粝米。问得几何？答曰：为粝米六升。</p>
<p>术曰：以粟求粝米，三之，五而一。</p>
<p>〔淳风等按：都术：以所求率乘所有数，以所有率为法。此术以粟求米，故 粟为所有数。三是米率，故三为所求率。五为粟率，故五为所有率。粟率五十， 米率三十，退位求之，故惟云三、五也。〕 今有粟二斗一升，欲为粺米。问得几何？答曰：为粺米一斗一升五十分 升之十七。</p>
<p>术曰：以粟求粺米，二十七之，五十而一。</p>
<p>〔淳风等按：粺米之率二十有七，故直以二十七之，五十而一也。〕 今有粟四斗五升，欲为米。问得几何？答曰：为米二斗一升五 分升之三。</p>
<p>术曰：以粟求米，十二之，二十五而一。</p>
<p>〔淳风等按：米之率二十有四，以为率太繁，故因而半之。半所求之 率，以乘所有之数。所求之率既减半，所有之率亦减半。是故十二乘之，二十五 而一也。〕 今有粟七斗九升，欲为御米。问得几何？答曰：为御米三斗三升五十分升之 九。</p>
<p>术曰：以粟求御米，二十一之，五十而一。</p>
<p>今有粟一斗，欲为小&lt;麦啇&gt;。问得几何？答曰：为小&lt;麦啇&gt;二升一十分升之 七。</p>
<p>术曰：以粟求小&lt;麦啇&gt;，二十七之，百而一。</p>
<p>〔淳风等按：小&lt;麦啇&gt;之率十三有半。半者二为母，以二通之，得二十七， 为所求率。又以母二通其粟率，得一百，为所有率。凡本率有分者，须即乘除也。</p>
<p>他皆仿此。〕 今有粟九斗八升，欲为大&lt;麦啇&gt;。问得几何？答曰：为大&lt;麦啇&gt;一十斗五升 二十五分升之二十一。</p>
<p>术曰：以粟求大&lt;麦啇&gt;，二十七之，二十五而一。</p>
<p>〔淳风等按：大&lt;麦啇&gt;之率五十有四。因其可半，故二十七之，亦如粟求 米，半其二率。〕 今有粟二斗三升，欲为粝饭。问得几何？答曰：为粝饭三斗四升半。</p>
<p>术曰：以粟求粝饭，三之，二而一。</p>
<p>〔淳风等按：粝饭之率七十有五，粟求粝饭，合以此数乘之。今以等数二十 有五约其二率，所求之率得三，所有之率得二，故以三乘二除。〕 今有粟三斗六升，欲为粺饭。问得几何？答曰：为粺饭三斗八升二十五 分升之二十二。</p>
<p>术曰：以粟求粺饭，二十七之，二十五而一。</p>
<p>〔淳风等按：此术与大&lt;麦啇&gt;多同。〕 今有粟八斗六升，欲为饭。问得几何？答曰：为饭八斗二升二 十五分升之一十四。</p>
<p>术曰：以粟求饭，二十四之，二十五而一。</p>
<p>〔淳风等按：&lt;麦啇&gt;饭率四十八。此亦半二率而乘除。〕 今有粟九斗八升，欲为御饭。问得几何？答曰：为御饭八斗二升二十五分升 之八。</p>
<p>术曰：以粟求御饭，二十一之，二十五而一。</p>
<p>〔淳风等按：此术半率，亦与饭多同。〕 今有粟三斗少半升，欲为菽。问得几何？答曰：为菽二斗七升一十分升之三。</p>
<p>今有粟四斗一升太半升，欲为荅。问得几何？答曰：为荅三斗七升半。</p>
<p>今有粟五斗太半升，欲为麻。问得几何？答曰：为麻四斗五升五分升之三。</p>
<p>今有粟一十斗八升五分升之二，欲为麦。问得几何？答曰：为麦九斗七升二 十五分升之一十四。</p>
<p>术曰：以粟求菽、荅、麻、麦，皆九之，十而一。</p>
<p>〔淳风等按：四术率并四十五，皆是为粟所求，俱合以此率乘其本粟。术欲 从省，先以等数五约之，所求之率得九，所有之率得十，故九乘十除，义由于此。〕 今有粟七斗五升七分升之四，欲为稻。问得几何？答曰：为稻九斗三十五分 升之二十四。</p>
<p>术曰：以粟求稻，六之，五而一。</p>
<p>〔淳风等按：稻率六十，亦约二率而乘除。〕 今有粟七斗八升，欲为豉。问得几何？答曰：为豉九斗八升二十五分升之七。</p>
<p>术曰：以粟求豉，六十三之，五十而一。</p>
<p>今有粟五斗五升，欲为飧。问得几何？答曰：为飧九斗九升。</p>
<p>术曰：以粟求飧，九之，五而一。</p>
<p>〔淳风等按：飧率九十，退位，与求稻多同。〕 今有粟四斗，欲为熟菽。问得几何？答曰：为熟菽八斗二升五分升之四。</p>
<p>术曰：以粟求熟菽，二百七之，百而一。</p>
<p>〔淳风等按：熟菽之率一百三半。半者，其母二，故以母二通之。所求之率 既被二乘，所有之率随而俱长，故以二百七之，百而一。〕 今有粟二斗，欲为糵。问得几何？答曰：为糵七斗。</p>
<p>术曰：以粟求糵，七之，二而一。</p>
<p>〔淳风等按：糵率一百七十有五，合以此数乘其本粟。术欲从省，先以等数 二十五约之，所求之率得七，所有之率得二，故七乘二除。〕 今有粝米十五斗五升五分升之二，欲为粟。问得几何？答曰：为粟二十五斗 九升。</p>
<p>术曰：以粝米求粟，五之，三而一。</p>
<p>〔淳风等按：上术以粟求米，故粟为所有数，三为所求率，五为所有率。今 此以米求粟，故米为所有数，五为所求率，三为所有率。准都术求之，各合其数。</p>
<p>以下所有反求多同，皆准此。〕 今有粺米二斗，欲为粟。问得几何？答曰：为粟三斗七升二十七分升之一。</p>
<p>术曰：以粺米求粟，五十之，二十七而一。</p>
<p>今有米三斗少半升，欲为粟。问得几何？答曰：为粟六斗三升三十六 分升之七。</p>
<p>术曰：以米求粟，二十五之，十二而一。</p>
<p>今有御米十四斗，欲为粟。问得几何？答曰：为粟三十三斗三升少半升。</p>
<p>术曰：以御米求粟，五十之，二十一而一。</p>
<p>今有稻一十二斗六升一十五分升之一十四，欲为粟。问得几何？答曰：为粟 一十斗五升九分升之七。</p>
<p>术曰：以稻求粟，五之，六而一。</p>
<p>今有粝米一十九斗二升七分升之一，欲为粺米。问得几何？答曰：为粺 米一十七斗二升一十四分升之一十三。</p>
<p>术曰：以粝米求粺米，九之，十而一。</p>
<p>〔淳风等按：粺米率二十七，合以此数乘粝米。术欲从省，先以等数三约 之，所求之率得九，所有之率得十，故九乘而十除。〕 今有粝米六斗四升五分升之三，欲为粝饭。问得几何？答曰：为粝饭一十六 斗一升半。</p>
<p>术曰：以粝米求粝饭，五之，二而一。</p>
<p>〔淳风等按：粝饭之率七十有五，宜以本粝米乘此率数。术欲从省，先以等 数十五约之，所求之率得五，所有之率得二，故五乘二除，义由于此。〕 今有粝饭七斗六升七分升之四，欲为飧。问得几何？答曰：为飧九斗一升三 十五分升之三十一。</p>
<p>术曰：以粝饭求飧，六之，五而一。</p>
<p>〔淳风等按：飧率九十，为粝饭所求，宜以粝饭乘此率。术欲从省，先以等 数十五约之，所求之率得六，所有之率得五。以此，故六乘五除也。〕 今有菽一斗，欲为熟菽。问得几何？答曰：为熟菽二斗三升。</p>
<p>术曰：以菽求熟菽，二十三之，十而一。</p>
<p>〔淳风等按：熟菽之率一百三半。因其有半，各以母二通之，宜以菽数乘此 率。术欲从省，先以等数九约之，所求之率得一十一半，所有之率得五也。〕 今有菽二斗，欲为豉。问得几何？答曰：为豉二斗八升。</p>
<p>术曰：以菽求豉，七之，五而一。</p>
<p>〔淳风等按：豉率六十三，为菽所求，宜以菽乘此率。术欲从省，先以等数 九约之，所求之率得七，而所有之率得五也。〕 今有麦八斗六升七分升之三，欲为小&lt;麦啇&gt;。问得几何？答曰：为小&lt;麦啇&gt; 二斗五升一十四分升之一十三。</p>
<p>术曰：以麦求小&lt;麦啇&gt;，三之，十而一。</p>
<p>〔淳风等按：小&lt;麦啇&gt;之率十三半，宜以母二通之，以乘本麦之数。术欲从 省，先以等数九约之，所求之率得三，所有之率得十也。〕 今有麦一斗，欲为大&lt;麦啇&gt;。问得几何？答曰：为大抃一斗二升。</p>
<p>术曰：以麦求大&lt;麦啇&gt;，六之，五而一。</p>
<p>〔淳风等按：大&lt;麦啇&gt;之率五十有四，合以麦数乘此率。术欲从省，先以等 数九约之，所求之率得六，所有之率得五也。〕 今有出钱一百六十，买瓴甓十八枚。</p>
<p>〔瓴甓，砖也。〕 问枚几何？答曰：一枚八钱九分钱之八。</p>
<p>今有出钱一万三千五百，买竹二千三百五十个。问个几何？答曰：一个，五 钱四十七分钱之三十五。</p>
<p>经率术曰：以所买率为法，所出钱数为实，实如法得一。</p>
<p>〔此术犹经分。</p>
<p>淳风等按：今有之义，以所求率乘所有数，合以瓴甓一枚乘钱一百六十为实。</p>
<p>但以一乘不长，故不复乘，是以径将所买之率与所出之钱为法、实也。又按：此 今有之义。出钱为所有数，一枚为所求率，所买为所有率，而今有之，即得所求 数。一乘不长，故不复乘，是以径将所买之率为法，以所出之钱为实，实如法得 一枚钱。不尽者，等数而命分。〕 今有出钱五千七百八十五，买漆一斛六斗七升太半升。欲斗率之，问斗几何？ 答曰：一斗，三百四十五钱五百三分钱之一十五。</p>
<p>今有出钱七百二十，买缣一匹二丈一尺。欲丈率之，问丈几何？答曰：一丈， 一百一十八钱六十一分钱之二。</p>
<p>今有出钱二千三百七十，买布九匹二丈七尺。欲匹率之，问匹几何？答曰： 一匹，二百四十四钱一百二十九分钱之一百二十四。</p>
<p>今有出钱一万三千六百七十，买丝一石二钧一十七斤。欲石率之，问石几何？ 答曰：一石，八千三百二十六钱一百九十七分钱之百七十八。</p>
<p>术曰：以求所率乘钱数为实，以所买率为法，实如法得一。</p>
<p>〔淳风等按：今有之义，钱为所求率，物为所有数，故以乘钱，又以分母乘 之为实。实如法而一，有分者通之。所买通分内子为所有率，故以为法。得钱数 不尽而命分者，因法为母，实余为子。实见不满，故以命之。〕 今有出钱五百七十六，买竹七十八个。欲其大小率之，问各几何？答曰：其 四十八个，个七钱；其三十个，个八钱。</p>
<p>今有出钱一千一百二十，买丝一石二钧十八斤。欲其贵贱斤率之，问各几何？ 答曰：其二钧八斤，斤五钱；其一石一十斤，斤六钱。</p>
<p>今有出钱一万三千九百七十，买丝一石二钧二十八斤三两五铢。欲其贵贱石 率之，问各几何？答曰：其一钧九两一十二铢，石八千五十一钱；其一石一钧二 十七斤九两一十七铢，石八千五十二钱。</p>
<p>今有出钱一万三千九百七十，买丝一石二钧二十八斤三两五铢。欲其贵贱钧 率之，问各几何？答曰：其七斤一十两九铢，钧二千一十二钱；其一石二钧二十 斤八两二十铢，钧二千一十三钱。</p>
<p>今有出钱一万三千九百七十，买丝一石二钧二十八斤三两五铢。欲其贵贱斤 率之，问各几何？答曰：其一石二钧七斤十两四铢，斤六十七钱；其二十斤九两 一铢，斤六十八钱。</p>
<p>今有出钱一万三千九百七十，买丝一石二钧二十八斤三两五铢。欲其贵贱两 率之，问各几何？答曰：其一石一钧一十七斤一十四两一铢，两四钱；其一钧一 十斤五两四铢，两五钱。</p>
<p>其率术曰：各置所买石、钧、斤、两以为法，以所率乘钱数为实，实如法 而一。不满法者，反以实减法。法贱实贵。其求石、钧、斤、两，以积铢各除法、 实，各得其积数，余各为铢。</p>
<p>〔其率知，欲令无分。按：出钱五百七十六，买竹七十八个，以除钱，得七， 实余三十，是为三十个复可增一钱。然则实余之数即是贵者之数，故曰实贵也。</p>
<p>本以七十八个为法，今以贵者减之，则其余悉是贱者之数。故曰法贱也。其求石、 钧、斤、两，以积铢各除法、实，各得其积数，余各为铢者，谓石、钧、斤、两 积铢除实，又以石、钧、斤、两积铢除法，余各为铢，即合所问。〕 今有出钱一万三千九百七十，买丝一石二钧二十八斤三两五铢。欲其贵贱铢 率之，问各几何？答曰：其一钧二十斤六两十一铢，五铢一钱；其一石一钧七斤 一十二两一十八铢，六铢一钱。</p>
<p>今有出钱六百二十，买羽二千一百翭。</p>
<p>〔翭，羽本也。数羽称其本，犹数草木称其根株。〕 欲其贵贱率之，问各几何？答曰：其一千一百四十翭，三翭一钱； 其九百六十翭，四翭钱。</p>
<p>今有出钱九百八十，买矢榦五千八百二十枚。欲其贵贱率之，问各几何？答 曰：其三百枚，五枚一钱；其五千五百二十枚，六枚一钱。</p>
<p>反其率术曰：以钱数为法，所率为实，实如法而一。不满法者，反以实减 法。法少实多。二物各以所得多少之数乘法、实，即物数。</p>
<p>〔按：其率：出钱六百二十，买羽二千一百翭。反之，当二百四十钱， 一钱翭；其三百八十钱，一钱三翭。是钱有二价，物有贵贱。故以羽乘 钱，反其率也。</p>
<p>淳风等按：其率者，钱多物少；反其率知，钱少物多；多少相反，故曰反其 率也。其率者，以物数为法，钱数为实。反之知，以钱数为法，物数为实。不满 法知，实余也。当以余物化为钱矣。法为凡钱，而今以化钱减之，故以实减法。</p>
<p>法少知，经分之所得，故曰法少；实多者，余分之所益，故曰实多。乘实宜以多， 乘法宜以少，故曰各以其所得多少之数乘法、实，即物数。〕</p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://choy-mutao.github.io/images/user.png" alt="Author image" nopin="nopin" />
        
        
            Choy
        
        
        <time class="post-date" datetime="0001-01-01T00:00:00Z">
            1 Jan 0001
        </time>
    </footer>
</article>

    
        
<article class="post Basic">
    <header class="post-header">
        <h2 class="post-title"><a href="/basic/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%9C%AF/chapter3/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h1 id="卷三">卷三</h1>
<p>○ 衰分（以御贵贱禀税） 衰分 〔衰分，差也。〕 术曰：各置列衰； 〔列衰，相与率也。重叠，则可约。〕 副并为法，以所分乘未并者，各自为实。实如法而一。</p>
<p>〔法集而衰别。数，本一也。今以所分乘上别，以下集除之，一乘一除，适 足相消，故所分犹存，且各应率而别也。于今有术，列衰各为所求率，副并为所 有率，所分为所有数。又以经分言之，假令甲家三人，乙家二人，丙家一人，并 六人，共分十二，为人得二也。欲复作逐家者，则当列置人数，以一人所得乘之。</p>
<p>今此术先乘而后除也。〕 不满法者，以法命之。</p>
<p>今有大夫、不更、簪袅、上造、公士，凡五人，共猎得五鹿。欲以爵次分之， 问各得几何？答曰：大夫得一鹿三分鹿之二；不更得一鹿三分鹿之一；簪袅得一 鹿；上造得三分鹿之二；公士得三分鹿之一。</p>
<p>术曰：列置爵数，各自为衰。</p>
<p>〔爵数者，谓大夫五，不更四，簪袅三，上造二，公士一也。《墨子·号令 篇》以爵级为赐，然则战国之初有此名也。〕 副并为法。以五鹿乘未并者各自为实。实如法得一鹿。</p>
<p>〔今有术，列衰各为所求率，副并为所有率，今有鹿数为所有数，而今有之， 即得。〕 今有牛、马、羊食人苗。苗主责之粟五斗。羊主曰：“我羊食半马。”马主 曰：“我马食半牛。”今欲衰偿之，问各出几何？答曰：牛主出二斗八升七分升 之四；马主出一斗四升七分升之二；羊主出七升七分升之一。</p>
<p>术曰：置牛四、马二、羊一，各自为列衰，副并为法。以五斗乘未并者各自 为实。实如法得一斗。</p>
<p>〔淳风等按：此术问意，羊食半马，马食半牛，是谓四羊当一牛，二羊当一 马。今术置羊一、马二、牛四者，通其率以为列衰。〕 今有甲持钱五百六十，乙持钱三百五十，丙持钱一百八十，凡三人俱出关， 关税百钱。欲以钱数多少衰出之，问各几何？答曰：甲出五十一钱一百九分钱之 四十一；乙出三十二钱一百九分钱之一十二；丙出一十六钱一百九分钱之五十六。</p>
<p>术曰：各置钱数为列衰，副并为法。以百钱乘未并者，各自为实。实如法得 一钱。</p>
<p>〔淳风等按：此术甲、乙、丙持钱数以为列衰，副并为所有率，未并者各为 所求率，百钱为所有数，而今有之，即得。〕 今有女子善织，日自倍，五日织五尺。问日织几何？答曰：初日织一寸三十 一分寸之十九；次日织三寸三十一分寸之七；次日织六寸三十一分寸之十四；次 日织一尺二寸三十一分寸之二十八；次日织二尺五寸三十一分寸之二十五。</p>
<p>术曰：置一、二、四、八、十六为列衰，副并为法。以五尺乘未并者，各自 为实。实如法得一尺。</p>
<p>今有北乡算八千七百五十八，西乡算七千二百三十六，南乡算八千三百五十 六。凡三乡发徭三百七十八人。欲以算数多少衰出之，问各几何？答曰：北乡遣 一百三十五人一万二千一百七十五分人之一万一千六百三十七；西乡遣一百一十 二人一万二千一百七十五分人之四千四；南乡遣一百二十九人一万二千一百七十 五分人之八千七百九。</p>
<p>术曰：各置算数为列衰， 〔淳风等按：三乡算数，约，可半者，为列衰。〕 副并为法。以所发徭人数乘未并者，各自为实。实如法得一人。</p>
<p>〔按：此术，今有之义也。〕 今有禀粟，大夫、不更、簪袅、上造、公士，凡五人，一十五斗。今有大夫 一人后来，亦当禀五斗。仓无粟，欲以衰出之，问各几何？答曰：大夫出一斗四 分斗之一；不更出一斗；簪袅出四分斗之三；上造出四分斗之二；公士出四分斗 之一。</p>
<p>术曰：各置所禀粟斛，斗数、爵次均之，以为列衰。副并而加后来大夫亦五 斗，得二十以为法。以五斗乘未并者，各自为实。实如法得一斗。</p>
<p>〔禀前五人十五斗者，大夫得五斗，不更得四斗，簪袅得三斗，上造得二斗， 公士得一斗。欲令五人各依所得粟多少减与后来大夫，即与前来大夫同。据前来 大夫已得五斗，故言亦也。各以所得斗数为衰，并得十五，而加后来大夫亦五斗， 凡二十，为法也。是为六人共出五斗，后来大夫亦俱损折。今有术，副并为所有 率，未并者各为所求率，五斗为所有数，而今有之，即得。〕 今有禀粟五斛，五人分之。欲令三人得三，二人得二，问各几何？答曰：三 人，人得一斛一斗五升十三分升之五；二人，人得七斗六升十三分升之十二。</p>
<p>术曰：置三人，人三；二人，人二，为列衰。副并为法。以五斛乘未并者各 自为实。实如法得一斛。</p>
<p>反衰术曰：列置衰而令相乘，动者为不动者衰。</p>
<p>今有大夫、不更、簪袅、上造、公士凡五人，共出百钱。欲令高爵出少，以 次渐多，问各几何？答曰：大夫出八钱一百三十七分钱之一百四；不更出一十钱 一百三十七分钱之一百三十；簪袅出一十四钱一百三十七分钱之八十二；上造出 二十一钱一百三十七分钱之一百二十三；公士出四十三钱一百三十七分钱之一百 九。</p>
<p>术曰：置爵数，各自为衰，而反衰之。副并为法。以百钱乘未并者，各自为 实。实如法得一钱。</p>
<p>〔以爵次言之，大夫五、不更四。欲令高爵得多者，当使大夫一人受五分， 不更一人受四分。人数为母，分数为子。母同则子齐，齐即衰也。故上衰分宜以 五、四为列焉。今此令高爵出少，则当大夫五人共出一人分，不更四人共出一人 分，故谓之反衰。人数不同，则分数不齐。当令母互乘子。母互乘子，则动者为 不动者衰也。亦可先同其母，各以分母约，其子为反衰。副并为法。以所分乘未 并者，各自为实。实如法而一。〕 今有甲持粟三升，乙持粝米三升，丙持粝饭三升。欲令合而分之，问各几何？ 答曰：甲二升一十分升之七；乙四升一十分升之五；丙一升一十分升之八。</p>
<p>术曰：以粟率五十、粝米率三十、粝饭率七十五为衰，而反衰之。副并为法。</p>
<p>以九升乘未并者，各自为实。实如法得一升。</p>
<p>〔按：此术，三人所持升数虽等，论其本率，精粗不同。米率虽少，令最得 多；饭率虽多，反使得少。故令反之，使精得多而粗得少。于今有术，副并为所 有率，未并者各为所求率，九升为所有数，而今有之，即得。〕 今有丝一斤，价直二百四十。今有钱一千三百二十八，问得丝几何？答曰： 五斤八两一十二铢五分铢之四。</p>
<p>术曰：以一斤价数为法，以一斤乘今有钱数为实。实如法得丝数。</p>
<p>〔按：此术今有之义，以一斤价为所有率，一斤为所求率，今有钱为所有数， 而今有之，即得。〕 今有丝一斤，价直三百四十五。今有丝七两一十二铢，问得钱几何？答曰： 一百六十一钱三十二分钱之二十三。</p>
<p>术曰：以一斤铢数为法，以一斤价数乘七两一十二铢为实。实如法得钱数。</p>
<p>〔淳风等按：此术亦今有之义。以丝一斤铢数为所有率，价钱为所求率，今 有丝为所有数，而今有之，即得。〕 今有缣一丈，价直一百二十八。今有缣一匹九尺五寸，问得钱几何？答曰： 六百三十三钱五分钱之三。</p>
<p>术曰：以一丈寸数为法，以价钱数乘今有缣寸数为实。实如法得钱数。</p>
<p>〔淳风等按：此术亦今有之义。以缣一丈寸数为所有率，价钱为所求率，今 有缣寸数为所有数，而今有之，即得。〕 今有布一匹，价直一百二十五。今有布二丈七尺，问得钱几何？答曰：八十 四钱八分钱之三。</p>
<p>术曰：以一匹尺数为法，今有布尺数乘价钱为实。实如法得钱数。</p>
<p>〔淳风等按：此术亦今有之义。以一匹尺数为所有率，价钱为所求率，今有 布为所有数，今有之，即得。〕 今有素一匹一丈，价直六百二十五。今有钱五百，问得素几何？答曰：得素 一匹。</p>
<p>术曰：以价直为法，以一匹一丈尺数乘今有钱数为实。实如法得素数。</p>
<p>〔淳风等按：此术亦今有之义。以价钱为所有率，五丈尺数为所求率，今有 钱为所有数，今有之，即得。〕 今有与人丝一十四斤，约得缣一十斤。今与人丝四十五斤八两，问得缣几何？ 答曰：三十二斤八两。</p>
<p>术曰：以一十四斤两数为法，以一十斤乘今有丝两数为实。实如法得缣数。</p>
<p>〔淳风等按：此术亦今有之义。以一十四斤两数为所有率，一十斤为所求率， 今有丝为所有数，而今有之，即得。〕 今有丝一斤，耗七两。今有丝二十三斤五两，问耗几何？答曰：一百六十三 两四铢半。</p>
<p>术曰：以一斤展十六两为法。以七两乘今有丝两数为实。实如法得耗数。</p>
<p>〔淳风等按：此术亦今有之义。以一斤为十六两为所有率，七两为所求率， 今有丝为所有数，而今有之，即得。〕 今有生丝三十斤，干之，耗三斤十二两。今有干丝一十二斤，问生丝几何？ 答曰：一十三斤一十一两十铢七分铢之二。</p>
<p>术曰：置生丝两数，除耗数，余，以为法。</p>
<p>〔馀四百二十两，即干丝率。〕 三十斤乘干丝两数为实。实如法得生丝数。</p>
<p>〔凡所得率，如细则俱细，粗则俱粗，两数相抱而已。故品物不同，如上缣、 丝之比，相与率焉。三十斤凡四百八十两，今生丝率四百八十两，今干丝率四百 二十两，则其数相通。可俱为铢，可俱为两，可俱为斤，，无所归滞也。若然， 宜以所有干丝斤数乘生丝两数为实。今以斤、两错互而亦同归者，使干丝以两数 为率，生丝以斤数为率，譬之异类，亦各有一定之势。</p>
<p>淳风等按：此术，置生丝两数，除耗数，余即干丝之率，于今有术为所有率； 三十斤为所求率，干丝两数为所有数。凡所为率者，细则俱细，粗则俱粗。今有 一斤乘两知，干丝即以两数为率，生丝即以斤数为率，譬之异物，各有一定之率 也。〕 今有田一亩，收粟六升太半升。今有田一顷二十六亩一百五十九步，问收粟 几何？答曰：八斛四斗四升一十二分升之五。</p>
<p>术曰：以亩二百四十步为法。以六升太半升乘今有田积步为实。实如法得粟 数。</p>
<p>〔淳风等按：此术亦今有之义。以一亩步数为所有率，六升太半升为所求率， 今有田积步为所有数，而今有之，即得。〕 今有取保，一岁价钱二千五百。今先取一千二百，问当作日几何？答曰：一 百六十九日二十五分日之二十三。</p>
<p>术曰：以价钱为法，以一岁三百五十四日乘先取钱数为实。实如法得日数。</p>
<p>〔淳风等按：此术亦今有之义。以价为所有率，一岁日数为所求率，取钱为 所有数，而今有之，即得。〕 今有贷人千钱，月息三十。今有贷人七百五十钱，九日归之，问息几何？答 曰：六钱四分钱之三。</p>
<p>术曰：以月三十日乘千钱为法。</p>
<p>〔以三十日乘千钱为法者，得三万，是为贷人钱三万，一日息三十也。〕 以息三十乘今所贷钱数，又以九日乘之，为实。实如法得一钱。</p>
<p>〔以九日乘今所贷钱为今一日所有钱，于今有术为所有数，息三十为所求率； 三万钱为所有率。此又可以一月三十日约息三十钱，为十分一日，以乘今一日所 有钱为实；千钱为法。为率者，当等之于一也。故三十日或可乘本，或可约息， 皆所以等之也。〕</p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://choy-mutao.github.io/images/user.png" alt="Author image" nopin="nopin" />
        
        
            Choy
        
        
        <time class="post-date" datetime="0001-01-01T00:00:00Z">
            1 Jan 0001
        </time>
    </footer>
</article>

    
        
<article class="post Basic">
    <header class="post-header">
        <h2 class="post-title"><a href="/basic/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%9C%AF/chapter4/"></a></h2>
    </header>
    <section class="post-excerpt">
      <p>
          <section class="post-content">
            <h1 id="卷四">卷四</h1>
<p>○ 少广（以御积幂方圆） 少广 〔淳风等按：一亩之田，广一步，长二百四十步。今欲截取其从少，以益其 广，故曰少广。〕 术曰：置全步及分母子，以最下分母遍乘诸分子及全步， 〔淳风等按：以分母乘全步者，通其分也；以母乘子者，齐其子也。〕 各以其母除其子，置之于左，命通分者，又以分母遍乘诸分子及已通者，皆 通而同之。并之为法。</p>
<p>〔淳风等按：诸子悉通，故可并之为法。亦宜用合分术，列数尤多，若用乘 则算数至繁，故别制此术，从省约。〕 置所求步数，以全步积分乘之为实。</p>
<p>〔此以田广为法，以亩积步为实。法有分者，当同其母，齐其子，以同乘法 实，而并齐于法。今以分母乘全步及子，子如母而一，并以并全法，则法实俱长， 意亦等也。故如法而一，得从步数。〕 实如法而一，得从步。</p>
<p>今有田广一步半。求田一亩，问从几何？答曰：一百六十步。</p>
<p>术曰：下有半，是二分之一。以一为二，半为一，并之，得三，为法。置田 二百四十步，亦以一为二乘之，为实。实如法得从步。</p>
<p>今有田广一步半、三分步之一。求田一亩，问从几何？答曰：一百三十步一 十一分步之一十。</p>
<p>术曰：下有三分，以一为六，半为三，三分之一为二，并之，得一十一，为 法。置田二百四十步，亦以一为六乘之，为实。实如法得从步。</p>
<p>今有田广一步半、三分步之一、四分步之一。求田一亩，问从几何？答曰： 一百一十五步五分步之一。</p>
<p>术曰：下有四分，以一为一十二，半为六，三分之一为四，四分之一为三， 并之，得二十五，以为法。置田二百四十步，亦以一为一十二乘之，为实。实如 法而一，得从步。</p>
<p>今有田广一步半、三分步之一、四分步之一、五分步之一。求田一亩，问从 几何？答曰：一百五步一百三十七分步之一十五。</p>
<p>术曰：下有五分，以一为六十，半为三十，三分之一为二十，四分之一为一 十五，五分之一为一十二，并之，得一百三十七，以为法。置田二百四十步，亦 以一为六十乘之，为实。实如法得从步。</p>
<p>今有田广一步半、三分步之一、四分步之一、五分步之一、六分步之一。求 田一亩，问从几何？答曰：九十七步四十九分步之四十七。</p>
<p>术曰：下有六分，以一为一百二十，半为六十，三分之一为四十，四分之一 为三十，五分之一为二十四，六分之一为二十，并之，得二百九十四，以为法。</p>
<p>置田二百四十步，亦以一为一百二十乘之，为实。实如法得从步。</p>
<p>今有田广一步半、三分步之一、四分步之一、五分步之一、六分步之一、七 分步之一。求田一亩，问从几何？答曰：九十二步一百二十一分步之六十八。</p>
<p>术曰：下有七分，以一为四百二十，半为二百一十，三分之一为一百四十， 四分之一为一百五，五分之一为八十四，六分之一为七十，七分之一为六十，并 之，得一千八十九，以为法。置田二百四十步，亦以一为四百二十乘之，为实。</p>
<p>实如法得从步。</p>
<p>今有田广一步半、三分步之一、四分步之一、五分步之一、六分步之一、七 分步之一、八分步之一。求田一亩，问从几何？答曰：八十八步七百六十一分步 之二百三十二。</p>
<p>术曰：下有八分，以一为八百四十，半为四百二十，三分之一为二百八十， 四分之一为二百一十，五分之一为一百六十八，六分之一为一百四十，七分之一 为一百二十，八分之一为一百五，并之，得二千二百八十三，以为法。置田二百 四十步，亦以一为八百四十乘之，为实。实如法得从步。</p>
<p>今有田广一步半、三分步之一、四分步之一、五分步之一、六分步之一、七 分步之一、八分步之一、九分步之一。求田一亩，问从几何？答曰：八十四步七 千一百二十九分步之五千九百六十四。</p>
<p>术曰：下有九分，以一为二千五百二十，半为一千二百六十，三分之一为八 百四十，四分之一为六百三十，五分之一为五百四，六分之一为四百二十，七分 之一为三百六十，八分之一为三百一十五，九分之一为二百八十，并之，得七千 一百二十九，以为法。置田二百四十步，亦以一为二千五百二十乘之，为实。实 如法得从步。</p>
<p>今有田广一步半、三分步之一、四分步之一、五分步之一、六分步之一、七 分步之一、八分步之一、九分步之一、十分步之一。求田一亩、问从几何？答曰： 八十一步七千三百八十一分步之六千九百三十九。</p>
<p>术曰：下有一十分，以一为二千五百二十，半为一千二百六十，三分之一为 八百四十，四分之一为六百三十，五分之一为五百四，六分之一为四百二十，七 分之一为三百六十，八分之一为三百一十五，九分之一为二百八十，十分之一为 二百五十二，并之，得七千三百八十一，以为法。置田二百四十步，亦以一为二 千五百二十乘之，为实。实如法得从步。</p>
<p>今有田广一步半、三分步之一、四分之步一、五分步之一、六分步之一、七 分步之一、八分步之一、九分步之一、十分步之一、十一分步之一。求田一亩， 问从几何？答曰：七十九步八万三千七百一十一分步之三万九千六百三十一。</p>
<p>术曰：下有一十一分，以一为二万七千七百二十，半为一万三千八百六十， 三分之一为九千二百四十，四分之一为六千九百三十，五分之一为五千五百四十 四，六分之一为四千六百二十，七分之一为三千九百六十，八分之一为三千四百 六十五，九分之一为三千八十，一十分之一为二千七百七十二，一十一分之一为 二千五百二十，并之，得八万三千七百一十一，以为法。置田二百四十步，亦以 一为二万七千七百二十乘之，为实。实如法得从步。</p>
<p>今有田广一步半、三分步之一、四分步之一，五分步之一、六分步之一、七 分步之一、八分步之一、九分步之一、十分步之一、十一分步之一、十二分步之 一。求田一亩，问从几何？答曰：七十七步八万六千二十一分步之二万九千一百 八十三。</p>
<p>术曰：下有一十二分，以一为八万三千一百六十，半为四万一千五百八十， 三分之一为二万七千七百二十，四分之一为二万七百九十，五分之一为一万六千 六百三十二，六分之一为一万三千八百六十，七分之一为一万一千八百八十，八 分之一为一万三百九十五，九分之一为九千二百四十，一十分之一为八千三百一 十六，十一分之一为七千五百六十，十二分之一为六千九百三十，并之，得二十 五万八千六十三，以为法。置田二百四十步，亦以一为八万三千一百六十乘之， 为实。实如法得从步。</p>
<p>〔淳风等按：凡为术之意，约省为善。宜云“下有一十二分，以一为二万七 千七百二十，半为一万三千八百六十，三分之一为九千二百四十，四分之一为六 千九百三十，五分之一为五千五百四十四，六分之一为四千六百二十，七分之一 为三千九百六十，八分之一为三千四百六十五，九分之一为三千八十，十分之一 为二千七百七十二，十一分之一为二千五百二十，十二分之一为二千三百一十， 并之，得八万六千二十一，以为法。置田二百四十步，亦以一为二万七千七百二 十乘之，以为实。实如法得从步。”其术亦得知，不繁也。〕 今有积五万五千二百二十五步，问为方几何？答曰：二百三十五步。</p>
<p>又有积二万五千二百八十一步，问为方几何？答曰：一百五十九步。</p>
<p>又有积七万一千八百二十四步，问为方几何？答曰：二百六十八步。</p>
<p>又有积五十六万四千七百五十二步四分步之一，问为方几何？答曰：七百五 十一步半。</p>
<p>又有积三十九亿七千二百一十五万六百二十五步，问为方几何？答曰：六万 三千二十五步。</p>
<p>○ 开方 〔求方幂之一面也。〕 术曰：置积为实。借一算，步之，超一等。</p>
<p>〔言百之面十也。言万之面百也。〕 议所得，以一乘所借一算为法，而以除。</p>
<p>〔先得黄甲之面，上下相命，是自乘而除也。〕 除已，倍法为定法。</p>
<p>〔倍之者，豫张两面朱幂定袤，以待复除，故曰定法。〕 其复除，折法而下。</p>
<p>〔欲除朱幂者，本当副置所得成方，倍之为定法，以折、议、乘，而以除。</p>
<p>如是当复步之而止，乃得相命。故使就上折下。〕 复置借算，步之如初。以复议一乘之， 〔欲除朱幂之角黄乙之幂，其意如初之所得也。〕 所得副以加定法，以除。以所得副从定法。</p>
<p>〔再以黄乙之面加定法者，是则张两青幂之袤。〕 复除，折下如前。若开之不尽者，为不可开，当以面命之。</p>
<p>〔术或有以借算加定法而命分者，虽粗相近，不可用也。凡开积为方，方之 自乘当还复有积分。令不加借算而命分，则常微少；其加借算而命分，则又微多。</p>
<p>其数不可得而定。故惟以面命之，为不失耳。譬犹以三除十，以其余为三分之一， 而复其数可以举。不以面命之，加定法如前，求其微数。微数无名者以为分子， 其一退以十为母，其再退以百为母。退之弥下，其分弥细，则朱幂虽有所弃之数， 不足言之也。〕 若实有分者，通分内子为定实，乃开之。讫，开其母，报除。</p>
<p>〔淳风等按：分母可开者，并通之积先合二母。既开之后，一母尚存，故开 分母，求一母为法，以报除也。〕 若母不可开者，又以母乘定实，乃开之。讫，令如母而一。</p>
<p>〔淳风等按：分母不可开者，本一母也。又以母乘之，乃合二母。既开之后， 亦一母存焉，故令一母而一，得全面也。</p>
<p>又按：此术“开方”者，求方幂之面也。借一算者，假借一算，空有列位之 名，而无除积之实。方隅得面，是故借算列之于下。“步之超一等”者，方十自 乘，其积有百，方百自乘，其积有万，故超位，至百而言十，至万而言百。“议 所得，以一乘所借算为法，而以除”者，先得黄甲之面，以方为积者两相乘，故 开方除之，还令两面上下相命，是自乘而除之。“除已，倍法为定法”者，实积 未尽，当复更除，故豫张两面朱幂袤，以待复除，故曰定法。“其复除，折法而 下”者，欲除朱幂，本当副置所得成方，倍之为定法，以折、议、乘之，而以除， 如是，当复步之而止，乃得相命。故使就上折之而下。“复置借算，步之如初， 以复议一乘之，所得副以加定法，以定法除”者。欲除朱幂之角黄乙之幂。“以 所得副从定法”者，再以黄乙之面加定法，是则张两青幂之袤，故如前开之，即 合所问。〕 今有积一千五百一十八步四分步之三。问为圆周几何？答曰：一百三十五步。</p>
<p>〔于徽术，当周一百三十八步一十分步之一。</p>
<p>淳风等按：此依密率，为周一百三十八步五十分步之九。〕 又有积三百步，问为圆周几何？答曰：六十步。</p>
<p>〔于徽术，当周六十一步五十分步之十九。</p>
<p>淳风等按：依密率，为周六十一步一百分步之四十一。〕 开圆术曰：置积步数，以十二乘之，以开方除之，即得周。</p>
<p>〔此术以周三径一为率，与旧圆田术相返覆也。于徽术，以三百一十四乘积， 如二十五而一，所得，开方除之，即周也。开方除之，即径。是为据见幂以求周， 犹失之于微少。其以二百乘积，一百五十七而一，开方除之，即径，犹失之于微 多。</p>
<p>淳风等按：此注于徽术求周之法，其中不用“开方除之，即径”六字，今 本有者，衍剩也。依密率，八十八乘之，七而一。按周三径一之率，假令周六径 二，半周半径相乘得幂三，周六自乘得三十六。俱以等数除幂，得一周之数十二 也。其积：本周自乘，合以一乘之，十二而一，得积三也。术为一乘不长，故以 十二而一，得此积。今还原，置此积三，以十二乘之者，复其本周自乘之数。凡 物自乘，开方除之，复其本数，故开方除之，即周。〕 今有积一百八十六万八百六十七尺， 〔此尺谓立方尺也。凡物有高、深而言积者，曰立方。〕 问为立方几何？答曰：一百二十三尺。</p>
<p>又有积一千九百五十三尺八分尺之一，问为立方几何？答曰：一十二尺半。</p>
<p>又有积六万三千四百一尺五百一十二分尺之四百四十七，问为立方几何？答 曰：三十九尺八分尺之七。</p>
<p>又有积一百九十三万七千五百四十一尺二十七分尺之一十七，问为立方几何？ 答曰：一百二十四尺太半尺。</p>
<p>开立方 〔立方适等，求其一面也。〕 术曰：置积为实。借一算，步之，超二等。</p>
<p>〔言千之面十，言百万之面百。〕 议所得，以再乘所借一算为法，而除之。</p>
<p>〔再乘者，亦求为方幂。以上议命而除之，则立方等也。〕 除已，三之为定法。</p>
<p>〔为当复除，故豫张三面，以定方幂为定法也。〕 复除，折而下。</p>
<p>〔复除者，三面方幂以皆自乘之数，须得折、议，定其厚薄尔。开平幂者， 方百之面十；开立幂者，方千之面十。据定法已有成方之幂，故复除当以千为百， 折下一等也。〕 以三乘所得数，置中行。</p>
<p>〔设三廉之定长。〕 复借一算，置下行。</p>
<p>〔欲以为隅方。立方等未有定数，且置一算定其位。〕 步之，中超一，下超二等。</p>
<p>〔上方法，长自乘而一折，中廉法，但有长，故降一等；下隅法，无面长， 故又降一等也。〕 复置议，以一乘中， 〔为三廉备幂也。〕 再乘下， 〔令隅自乘，为方幂也。〕 皆副以加定法。以定法除。</p>
<p>〔三面、三廉、一隅皆已有幂，以上议命之而除，去三幂之厚也。〕 除已，倍下，并中，从定法。</p>
<p>〔凡再以中、三以下，加定法者，三廉各当以两面之幂连于两方之面，一隅 连于三廉之端，以待复除也。言不尽意，解此要当以棋，乃得明耳。〕 复除，折下如前。开之不尽者，亦为不可开。</p>
<p>〔术亦有以定法命分者，不如故幂开方，以微数为分也。〕 若积有分者，通分内子为定实。定实乃开之。讫，开其母以报除。</p>
<p>〔淳风等按：分母可开者，并通之积先合三母。既开之后一母尚存，故开分 母，求一母，为法，以报除也。〕 若母不可开者，又以母再乘定实，乃开之。讫，令如母而一。</p>
<p>〔淳风等按：分母不可开者，本一母也。又以母再乘之，令合三母。既开之 后，一母犹存，故令一母而一，得全面也。</p>
<p>按：“开立方”知，立方适等，求其一面之数。“借一算，步之，超二等” 者，但立方求积，方再自乘，就积开之，故超二等，言千之面十，言百万之面百。</p>
<p>“议所得，以再乘所借算为法，而以除”知，求为方幂，以议命之而除，则立方 等也。“除已，三之为定法”，为积未尽，当复更除，故豫张三面已定方幂为定 法。“复除，折而下”知，三面方幂皆已有自乘之数，须得折、议定其厚薄。据 开平方，百之面十，其开立方，即千之面十。而定法已有成方之幂，故复除之者， 当以千为百，折下一等。“以三乘所得数，置中行”者，设三廉之定长。“复借 一算，置下行”者，欲以为隅方，立方等未有数，且置一算定其位也。“步之， 中超一，下超二”者，上方法长自乘而一折，中廉法但有长，故降一等，下隅法 无面长，故又降一等。“复置议，以一乘中”者，为三廉备幂。“再乘下”，当 令隅自乘为方幂。“皆副以加定法，以定法除者，三面、三廉、一隅皆已有幂， 以上议命之而除，去三幂之厚。“除已，倍下、并中，从定法”者，三廉各当以 两面之幂连于两方之面，一隅连于三廉之端，以待复除。其开之不尽者，折下如 前，开方，即合所问。“有分者，通分内子开之。讫，开其母以报除”，“可开 者，并通之积，先合三母；既开之后，一母尚存，故开分母”者，“求一母为法， 以报除。”“若母不可开者，又以母再乘定实，乃开之。讫，令如母而一”，分 母不可开者，本一母，又以母再乘，令合三母，既开之后，亦一母尚存。故令如 母而一，得全面也。〕 今有积四千五百尺。</p>
<p>〔亦谓立方之尺也。〕 问为立圆径几何？答曰：二十尺。</p>
<p>〔依密率，立圆径二十尺，计积四千一百九十尺二十一分尺之一十。〕 又有积一万六千四百四十八亿六千六百四十三万七千五百尺。问为立圆径几 何？答曰：一万四千三百尺。</p>
<p>〔依密率，为径一万四千六百四十三尺四分尺之三。〕 开立圆术曰：置积尺数，以十六乘之，九而一，所得，开立方除之，即立 圆径。</p>
<p>〔立圆，即丸也。为术者，盖依周三径一之率。令圆幂居方幂四分之三，圆 囷居立方亦四分之三。更令圆囷为方率十二，为丸率九，丸居圆囷又四分之三也。</p>
<p>置四分自乘得十六，三分自乘得九，故丸居立方十六分之九也。故以十六乘积， 九而一，得立方之积。丸径与立方等，故开立方而除，得径也。然此意非也。何 以验之？取立方棋八枚，皆令立方一寸，积之为立方二寸。规之为圆囷，径二寸， 高二寸。又复横因之，则其形有似牟合方盖矣。八棋皆似陽马，圆然也。按：合 盖者，方率也，丸居其中，即圆率也。推此言之，谓夫圆囷为方率，岂不阙哉？ 以周三径一为圆率，则圆幂伤少；令圆囷为方率，则丸积伤多，互相通补，是以 九与十六之率偶与实相近，而丸犹伤多耳。观立方之内，合盖之外，虽衰杀有渐， 而多少不掩。判合总结，方圆相缠，浓纤诡互，不可等正。欲陋形措意，惧失正 理。敢不阙疑，以俟能言者。</p>
<p>黄金方寸，重十六两；金丸径寸，重九两，率生于此，未曾验也。《周官· 考工记》：“朅氏为量，改煎金锡则不耗，不耗然后权之，权之然后准之，准之 然后量之。”言炼金使极精，而后分之则可以为率也。令丸径自乘，三而一，开 方除之，即丸中之立方也。假令丸中立方五尺，五尺为句，句自乘幂二十五尺。</p>
<p>倍之得五十尺，以为弦幂，谓平面方五尺之弦也。以此弦为股，亦以五尺为句， 并句股幂得七十五尺，是为大弦幂。开方除之，则大弦可知也。大弦则中立方之 长邪，邪即丸径。故中立方自乘之幂于丸径自乘之幂，三分之一也。今大弦还乘 其幂，即丸外立方之积也。大弦幂开之不尽，令其幂七十五再自乘之，为面，命 得外立方积，四十二万一千八百七十五尺之面。又令中立方五尺自乘，又以方乘 之，得积一百二十五尺，一百二十五尺自乘，为面，命得积，一万五千六百二十 五尺之面。皆以六百二十五约之，外立方积，六百七十五尺之面，中立方积，二 十五尺之面也。</p>
<p>张衡算又谓立方为质，立圆为浑。衡言质之与中外之浑：六百七十五尺之面， 开方除之，不足一，谓外浑积二十六也；内浑，二十五之面，谓积五尺也。今徽 令质言中浑，浑又言质，则二质相与之率犹衡二浑相与之率也。衡盖亦先二质之 率推以言浑之率也。衡又言：“质，六十四之面；浑，二十五之面。”质复言浑， 谓居质八分之五也。又云：方，八之面；圆，五之面。”圆浑相推，知其复以圆 囷为方率，浑为圆率也，失之远矣。衡说之自然欲协其陰陽奇偶之说而不顾疏密 矣。虽有文辞，斯乱道破义，病也。置外质积二十六，以九乘之，十六而一，得 积十四尺八分尺之五，即质中之浑也。以分母乘全内子，得一百一十七。又置内 质积五，以分母乘之，得四十，是谓质居浑一百一十七分之四十，而浑率犹为伤 多也。假令方二尺，方四面，并得八尺也，谓之方周。其中令圆径与方等，亦二 尺也。圆半径以乘圆周之半，即圆幂也。半方以乘方周之半，即方幂也。然则方 周知，方幂之率也；圆周知，圆幂之率也。按：如衡术，方周率八之面，圆周率 五之面也。令方周六十四尺之面，圆周四十尺之面也。又令径二尺自乘，得径四 尺之面，是为圆周率十之面，而径率一之面也。衡亦以周三径一之率为非，是故 更著此法，然增周太多，过其实矣。</p>
<p>淳风等按：祖暅之谓刘徽、张衡二人皆以圆囷为方率，丸为圆率，乃设新 法。祖暅之开立圆术曰：“以二乘积，开立方除之，即立圆径。其意何也？取 立方棋一枚，令立枢于左后之下隅，从规去其右上之廉；又合而衡规之，去其前 上之廉。于是立方之棋分而为四，规内棋一，谓之内棋；规外棋三，谓之外棋。</p>
<p>规更合四棋，复横断之。以句股言之，令余高为句，内棋断上方为股，本方之数， 其弦也。句股之法：以句幂减弦幂，则余为股幂。若令余高自乘，减本方之幂， 余即内棋断上方之幂也。本方之幂即此四棋之断上幂。然则余高自乘，即外三棋 之断上幂矣。不问高卑，势皆然也。然固有所归同而途殊者尔。而乃控远以演类， 借况以析微。按：陽马方高数参等者，倒而立之，横截去上，则高自乘与断上幂 数亦等焉。夫叠棋成立积，缘幂势既同，则积不容异。由此观之，规之外三棋旁 蹙为一，即一陽马也。三分立方，则陽马居一，内棋居二可知矣。合八小方成一 大方，合八内棋成一合盖。内棋居小方三分之二，则合盖居立方亦三分之二，较 然验矣。置三分之二，以圆幂率三乘之，如方幂率四而一，约而定之，以为丸率。</p>
<p>故曰丸居立方二分之一也。”等数既密，心亦昭晢。张衡放旧，贻哂于后，刘徽 循故，未暇校新。夫岂难哉，抑未之思也。依密率，此立圆积，本以圆径再自乘， 十一乘之，二十一而一，得此积。今欲求其本积，故以二十一乘之，十一而一。</p>
<p>凡物再自乘，开立方除之，复其本数。故立方除之，即丸径也。〕</p>

          </section>
      </p>
      
    </section>
    <footer class="post-meta">
        
            <img class="author-thumb" src="https://choy-mutao.github.io/images/user.png" alt="Author image" nopin="nopin" />
        
        
            Choy
        
        
        <time class="post-date" datetime="0001-01-01T00:00:00Z">
            1 Jan 0001
        </time>
    </footer>
</article>

    

    <nav class="pagination" role="navigation">
	
	    <a class="newer-posts" href="/page/7/">&larr; Newer Posts</a>
	
	<span class="page-number">Page 8 of 17</span>
	
	    <a class="older-posts" href="/page/9/">Older Posts &rarr;</a>
	
</nav>


</main>

    <footer class="site-footer clearfix">
        <section class="copyright"><a href="">穆 道</a> </section>
        
        <section class="poweredby">Proudly generated by <a class="icon-hugo" href="https://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/syui/hugo-theme-air">hugo-theme-air</a> theme</section>
        
    </footer>
    </div>
    <script type="text/javascript" src="https://choy-mutao.github.io/js/jquery.js"></script>
    <script type="text/javascript" src="https://choy-mutao.github.io/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://choy-mutao.github.io/js/index.js"></script>
    <script src="https://choy-mutao.github.io/js/particles.min.js"></script>
    <script src="https://choy-mutao.github.io/js/particles.js"></script>  

</body>
</html>

