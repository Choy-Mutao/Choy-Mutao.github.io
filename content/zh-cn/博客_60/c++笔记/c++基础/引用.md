---
title: 引用
type: blog
date: 2019-04-19
---

## 描述

引用不是定义一个变量，而是已存在的变量取了一个别名，编译器不会为引用变量开辟内存
空间，它和它引用的变量共用同一块内存空间。

其使用的基本形式为：`类型& 引用变量名(对象名) = 引用实体。`

```cpp
#include <iostream>
using namespace std;
int main()
{
    int a = 10;
    int& b = a;//给变量a去了一个别名，叫b
    cout << "a = " << a << endl;//a打印结果为10
    cout << "b = " << b << endl;//b打印结果也是10
    b = 20;//改变b也就是改变了a
    cout << "a = " << a << endl;//a打印结果为20
    cout << "b = " << b << endl;//b打印结果也是为20
    return 0;
}
```

> 注：引用类型必须和引用实体是同种类型

## 引用的特性

### 1. 引用在定义时必须初始化

```cpp
void about_reference_1()
{
    int a = 10;
    int& b = a;
    int c = 10;
    int& d; // syntax error: reference variable "d" requires an initializer
    c = c;
}

```

### 2. 一个变量可以有多个引用

```cpp
int a = 10;
int& b = a;
int& c = a;
int& d = a;
```

### 3. 引用一旦引用了一个实体, 就不能再引用其他实体

```cpp
int a= 10;
int& b = a;
int c = 20;
b = c; // output: a = 20, b = 20, c = 20
```

## 常引用

上面提到，引用类型必须和引用实体是同种类型的。但是仅仅是同种类型，还不能保证能够
引用成功，我们若用一个普通引用类型去引用其对应的类型，但该类型被 const 所修饰，
那么引用将不会成功。

```cpp
int main()
{
    const int a = 10;
    //int& ra = a;    //该语句编译时会出错，a为常量
    const int& ra = a;//正确

    //int& b = 10;    //该语句编译时会出错，10为常量
    const int& b = 10;//正确
    return 0;
}
```

我们可以将被 const 修饰了的类型理解为安全的类型，因为其不能被修改。我们若将一个
安全的类型交给一个不安全的类型（可被修改），那么将不会成功。

## 引用的使用场景

### 1. 引用做参数

还记得 C 语言中的交换函数，学习 C 语言的时候经常用交换函数来说明传值和传址的区别
。现在我们学习了引用，可以不用指针作为形参了：

### 2. 引用做返回值

当然引用也能做返回值，但是要特别注意，我们返回的数据不能是函数内部创建的普通局部
变量，因为在函数内部定义的普通的局部变量会随着函数调用的结束而被销毁。我们返回的
数据必须是被 static 修饰或者是动态开辟的或者是全局变量等不会随着函数调用的结束而
被销毁的数据。

```cpp
int& Add(int a, int b)
{
    static int c = a + b;
    return c;
}
```

> 注意：如果函数返回时，出了函数作用域，返回对象还未还给系统，则可以使用引用返回
> ；如果已经还给系统了，则必须使用传值返回

## 引用和指针的区别

在语法概念上，引用就是一个别名，没有独立的空间，其和引用实体共用同一块空间。

```cpp
int main()
{
    int a = 10;
    //在语法上，这里给a这块空间取了一个别名，没有新开空间
    int& ra = a;
    ra = 20;

    //在语法上，这里定义了一个pa指针，开辟了4个字节（32位平台）的空间，用于存储a的地址
    int* pa = &a;
    *pa = 20;
    return 0;
}
```

1. 引用在定义时必须初始化，指针没有要求。
2. 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向
   任何一个同类型实体。
3. 没有 NULL 引用，但有 NULL 指针。
4. 在 sizeof 中的含义不同：引用的结果为引用类型的大小，但指针始终是地址空间所占
   字节个数（32 位平台下占 4 个字节）。
5. 引用进行自增操作就相当于实体增加 1，而指针进行自增操作是指针向后偏移一个类型
   的大小。
6. 有多级指针，但是没有多级引用。
7. 访问实体的方式不同，指针需要显示解引用，而引用是编译器自己处理。
8. 引用比指针使用起来相对更安全。
