# Graph $G=\{V,E\}$

* 无向图

* 有向图

* 顶点, 边, 弧, 弧头, 弧尾

* 无向完全图 & 有向完全图

* 稠密图 & 稀疏图

* TD(ID & OD)

* 边的权、网图

* 路径、路径长度

* 回路、简单路径、简单回路

* 子图

* 连通的、连通图、连通分量

* 强连通图、强连通分量

* 生成树 & 生成森林

## ADT

1. CreatGraph（G）输入图G 的顶点和边，建立图G 的存储。
2. DestroyGraph（G）释放图G 占用的存储空间。
3. GetVex（G，v）在图G 中找到顶点v，并返回顶点v 的相关信息。
4. PutVex（G，v，value）在图G 中找到顶点v，并将value 值赋给顶点v。
5. InsertVex（G，v）在图G 中增添新顶点v。
6. DeleteVex（G，v）在图G 中，删除顶点v 以及所有和顶点v 相关联的边或弧。
7. InsertArc（G，v，w）在图G 中增添一条从顶点v 到顶点w 的边或弧。
8. DeleteArc（G，v，w）在图G 中删除一条从顶点v 到顶点w 的边或弧。
9. DFSTraverse（G，v）在图G 中，从顶点v 出发深度优先遍历图G。
10. BFSTtaverse（G，v）在图G 中，从顶点v 出发广度优先遍历图G。
在一个图中，顶点是没有先后次序的，但当采用某一种确定的存储方式存储后，存储结构中顶点的存储次序构成了顶点之间的相对次序，这里用顶点在图中的位置表示该顶点的存储顺序；同样的道理，对一个顶点的所有邻接点，采用该顶点的第i 个邻接点表示与该顶点相邻接的某个顶点的存储顺序，在这种意义下，图的基本操作还有：

11. LocateVex（G，u）在图G 中找到顶点u，返回该顶点在图中位置。
12. FirstAdjVex（G，v）在图G 中，返回v 的第一个邻接点。若顶点在G 中没有邻接顶点，则返回“空”。
13. NextAdjVex（G，v，w）在图G 中，返回v 的（相对于w 的）下一个邻接顶点。若w 是v 的最后一个邻接点，则返回“空”。

